<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <!-- Favicon Link -->
    <link rel="icon" type="image/png" href="images/kwikmusiclogo.png" />
    <!-- PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="images/apple-touch-icon.png"
    />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="apple-mobile-web-app-title" content="KwikMusic" />
    <meta
      name="description"
      content="A mobile-first YouTube music streaming app"
    />
    <meta name="theme-color" content="#090111" />
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json" />

    <!-- Fonts: Modern, clean typefaces -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700&family=Outfit:wght@500;600;700;800&display=swap"
      rel="stylesheet"
    />
    <style>
      /* ===== Base Design Tokens & Typography (cleaned) ===== */
      :root {
        --km-bg-start: #0d0620;
        --km-bg-end: #1a1030;
        --km-accent: #6a0dad;
        --km-accent-alt: #f6c453;
        --km-text: #fff;
        --km-surface: rgba(255, 255, 255, 0.06);
        --km-surface-alt: rgba(255, 255, 255, 0.1);
        --km-radius-lg: 28px;
        --km-radius-md: 18px;
        --km-radius-sm: 10px;
      }

      /* ===== Reset and base styles for full viewport coverage ===== */
      * {
        box-sizing: border-box;
      }

      html {
        margin: 0;
        padding: 0;
        height: 100%;
        background: #090111;
        -webkit-text-size-adjust: 100%;
        /* Ensure background extends beyond viewport boundaries */
        background-attachment: fixed;
      }

      body,
      button,
      input,
      textarea {
        font-family: "Manrope", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, Arial, sans-serif;
      }
      h1,
      h2,
      h3,
      .app-title,
      .section-title,
      .playlist-name,
      .full-title,
      .mini-title {
        font-family: "Outfit", "Manrope", -apple-system, BlinkMacSystemFont,
          "Segoe UI", Roboto, sans-serif;
        letter-spacing: 0.5px;
      }
      .app-title {
        font-weight: 800;
      }
      .section-title {
        font-weight: 700;
      }
      .playlist-name {
        font-weight: 600;
      }
      .full-title,
      .mini-title {
        font-weight: 700;
      }
      body {
        margin: 0;
        padding: 0;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        background: radial-gradient(circle at 20% 20%, #22113f 0%, #120a24 60%),
          linear-gradient(135deg, var(--km-bg-start), var(--km-bg-end));
        color: var(--km-text);
        overflow: hidden;
        height: 100vh;
        height: 100dvh; /* Dynamic viewport height for mobile */
        min-height: -webkit-fill-available;
        display: flex;
        flex-direction: column;
        position: relative;
        /* Ensure body extends to cover status bar area */
        padding-top: 0;
        margin-top: 0;
      }

      /* Ensure app covers the entire viewport including status bar */
      .app-container {
        min-height: 100vh;
        min-height: 100dvh;
        min-height: -webkit-fill-available;
      }
      /* Animated abstract orbs */
      .bg-orbs {
        position: fixed;
        inset: 0;
        overflow: hidden;
        z-index: -1;
        filter: blur(60px) saturate(140%);
      }
      .bg-orbs .orb {
        position: absolute;
        width: 480px;
        height: 480px;
        background: radial-gradient(
          circle at 30% 30%,
          var(--km-accent-alt),
          transparent 70%
        );
        opacity: 0.25;
        animation: float 18s ease-in-out infinite;
        mix-blend-mode: screen;
      }
      .bg-orbs .orb.alt {
        background: radial-gradient(
          circle at 70% 70%,
          var(--km-accent),
          transparent 65%
        );
        animation-duration: 23s;
        animation-direction: reverse;
      }
      .bg-orbs .orb.third {
        background: radial-gradient(
          circle at 50% 50%,
          #ff7de6,
          transparent 60%
        );
        animation-duration: 28s;
        animation-delay: -6s;
      }
      @keyframes float {
        0% {
          transform: translate3d(-10%, -8%, 0) scale(1);
        }
        33% {
          transform: translate3d(25%, 10%, 0) scale(1.15);
        }
        66% {
          transform: translate3d(-5%, 35%, 0) scale(0.9);
        }
        100% {
          transform: translate3d(-10%, -8%, 0) scale(1);
        }
      }
      .app-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 20px 0;
        background: linear-gradient(135deg, #140a2a88, #1e123acc);
        backdrop-filter: blur(22px) saturate(140%);
        position: sticky;
        top: 0;
        z-index: 100;
        padding-top: env(safe-area-inset-top, 20px);
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      }
      .header-icons {
        display: inline-flex;
        align-items: center;
        gap: 12px;
      }
      .header-btn.desktop-only {
        display: none;
      }
      @media (min-width: 1024px) {
        .header-btn.desktop-only {
          display: inline-flex;
        }
      }
      .search-box {
        display: flex;
        background: linear-gradient(
          145deg,
          rgba(255, 255, 255, 0.08),
          rgba(255, 255, 255, 0.04)
        );
        border-radius: 32px;
        padding: 6px;
        backdrop-filter: blur(14px) saturate(160%);
        box-shadow: 0 6px 28px -10px rgba(0, 0, 0, 0.6),
          0 0 0 1px rgba(255, 255, 255, 0.06) inset;
      }
      .search-box:focus-within {
        box-shadow: 0 4px 22px -6px rgba(246, 196, 83, 0.45),
          0 0 0 1px rgba(246, 196, 83, 0.35) inset;
      }
      .app-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        position: relative;
      }
      .app-title {
        font-size: 28px;
        background: linear-gradient(45deg, #f6c453, #6a0dad);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      /* Enhanced rain/settings header button */
      .header-btn {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 44px;
        height: 44px;
        border-radius: 16px;
        cursor: pointer;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: linear-gradient(
              140deg,
              rgba(255, 255, 255, 0.14),
              rgba(255, 255, 255, 0.06)
            )
            padding-box,
          linear-gradient(
              150deg,
              rgba(246, 196, 83, 0.55),
              rgba(106, 13, 173, 0.55),
              rgba(246, 196, 83, 0.55)
            )
            border-box;
        backdrop-filter: blur(14px) saturate(160%);
        -webkit-backdrop-filter: blur(14px) saturate(160%);
        box-shadow: 0 4px 12px -4px rgba(0, 0, 0, 0.55),
          0 0 0 1px rgba(255, 255, 255, 0.1) inset,
          0 0 0 1px rgba(255, 255, 255, 0.05);
        transition: background 0.4s ease, box-shadow 0.35s ease,
          transform 0.35s ease;
        overflow: hidden;
      }
      .header-btn::after {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(
            circle at 30% 20%,
            rgba(255, 255, 255, 0.35),
            transparent 55%
          ),
          linear-gradient(
            120deg,
            rgba(246, 196, 83, 0.25),
            rgba(106, 13, 173, 0.15)
          );
        mix-blend-mode: screen;
        opacity: 0.55;
        pointer-events: none;
        transition: opacity 0.4s ease;
      }
      .header-btn .icon {
        width: 22px;
        height: 22px;
        color: #fff;
      }

      /* Recordings button badge */
      .header-btn.has-recordings::after {
        content: "";
        position: absolute;
        top: 8px;
        right: 8px;
        width: 8px;
        height: 8px;
        background: #ff4757;
        border-radius: 50%;
        border: 2px solid rgba(13, 6, 32, 0.8);
      }

      .header-btn:hover::after {
        opacity: 0.9;
      }
      .header-btn:active {
        transform: scale(0.94);
      }
      .header-btn:focus-visible {
        outline: 2px solid rgba(246, 196, 83, 0.6);
        outline-offset: 3px;
      }
      .header-btn.active {
        background: linear-gradient(
              145deg,
              rgba(246, 196, 83, 0.28),
              rgba(106, 13, 173, 0.28)
            )
            padding-box,
          linear-gradient(
              150deg,
              rgba(246, 196, 83, 0.65),
              rgba(106, 13, 173, 0.65)
            )
            border-box;
        box-shadow: 0 6px 22px -8px rgba(0, 0, 0, 0.65),
          0 0 0 1px rgba(255, 255, 255, 0.18) inset,
          0 0 18px -2px rgba(246, 196, 83, 0.55);
      }
      .header-btn.active::after {
        opacity: 1;
      }
      @media (hover: none) {
        .header-btn:hover {
          transform: none;
        }
      }

      .mini-artwork-ring {
        position: relative;
        width: 56px;
        height: 56px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .header-btn:hover {
        background: linear-gradient(
          145deg,
          rgba(30, 30, 40, 0.95),
          rgba(18, 14, 30, 0.92)
        );
        transform: scale(1.1);
      }
      /* Removed mini-player glow pseudo-element & pulse animation (cleanup) */
      /* (Old .header-btn.active block removed - superseded by enhanced styling above) */

      /* Main Content */
      .main-content {
        flex: 1;
        overflow-y: auto;
        padding: 12px 20px calc(90px + env(safe-area-inset-bottom)); /* bottom padding for footer nav + floating AI button */
        -webkit-overflow-scrolling: touch;
        transition: padding-bottom 0.35s ease;
      }
      .main-content.with-mini {
        padding-bottom: calc(170px + env(safe-area-inset-bottom)); /* extra space when mini player is shown */
      }
      /* When footer nav present and no mini-player, reserve exact space to prevent overlap without causing scroll */
      .footer-nav-wrap + .spacer {
        display: none;
      }

      /* Search Section */
      .search-section {
        margin-bottom: 20px;
      }

      .search-container {
        margin-bottom: 20px;
      }

      .search-box {
        display: flex;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 25px;
        padding: 5px;
        backdrop-filter: blur(10px);
      }

      #searchInput {
        flex: 1;
        background: none;
        border: none;
        padding: 15px 20px;
        color: white;
        font-size: 16px;
        outline: none;
      }

      #searchInput::placeholder {
        color: rgba(255, 255, 255, 0.6);
      }

      .search-button {
        background: linear-gradient(45deg, #f6c453, #6a0dad);
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .search-button:hover {
        transform: scale(1.1);
      }

      /* Search Results */
      .search-results {
        overflow-y: visible; /* no internal scroll needed initially */
        max-height: none;
      }

      /* Suggestions under search */
      .search-suggestions {
        margin-top: 6px;
        margin-bottom: 10px;
      }
      .search-suggestions .suggestion-item {
        display: flex;
        align-items: center;
        padding: 12px;
        margin: 8px 0;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
      }
      .search-suggestions .suggestion-item:hover {
        background: rgba(255, 255, 255, 0.1);
        transform: translateY(-2px);
      }

      .welcome-message {
        text-align: center;
        padding: 8px 12px 2px; /* shrink bottom */
        margin-top: -2px;
        margin-bottom: 0; /* no extra space to trigger scroll */
      }
      .search-results {
        margin-bottom: 0;
        padding-bottom: 0;
      }

      .welcome-message h2 {
        font-size: 24px;
        margin-bottom: 10px;
        color: #f6c453;
      }

      .welcome-message p {
        color: rgba(255, 255, 255, 0.7);
        font-size: 16px;
      }

      .search-result-item {
        display: flex;
        align-items: center;
        padding: 15px;
        margin: 10px 0;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 15px;
        cursor: pointer;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
      }

      .search-result-item:hover {
        background: rgba(255, 255, 255, 0.1);
        transform: translateY(-2px);
      }

      .result-thumbnail {
        width: 60px;
        height: 60px;
        border-radius: 10px;
        overflow: hidden;
        margin-right: 15px;
        flex-shrink: 0;
      }

      .result-thumbnail img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .result-info {
        flex: 1;
        min-width: 0;
      }

      .result-title {
        font-weight: 600;
        font-size: 16px;
        margin-bottom: 5px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .result-channel {
        color: rgba(255, 255, 255, 0.7);
        font-size: 14px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .result-duration {
        color: rgba(255, 255, 255, 0.5);
        font-size: 12px;
        margin-left: 10px;
        flex-shrink: 0;
      }

      /* Mini Player */
      .mini-player {
        position: fixed;
        bottom: calc(70px + env(safe-area-inset-bottom)); /* float above footer capsule */
        left: 50%;
        transform: translateX(-50%);
        width: calc(100% - 32px);
        max-width: 560px;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.1),
          rgba(255, 255, 255, 0.06)
        );
        backdrop-filter: blur(16px);
        -webkit-backdrop-filter: blur(16px);
        border: 1px solid rgba(255, 255, 255, 0.16);
        border-radius: 999px;
        padding: 10px 12px;
        z-index: 1000;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease,
          background 0.3s ease;
        box-shadow: 0 4px 14px rgba(0, 0, 0, 0.28);
        will-change: transform;
        touch-action: none; /* allow custom gesture handling without browser scroll */
      }
      .mini-player:hover {
        transform: translate(-50%, -2px);
        box-shadow: 0 14px 36px rgba(0, 0, 0, 0.42);
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.12),
          rgba(255, 255, 255, 0.08)
        );
      }

      .mini-player-content {
        display: flex;
        align-items: center;
        gap: 15px;
      }

      /* Unified Progress Ring + Artwork */
      .mini-artwork-ring {
        position: relative;
        width: 56px;
        height: 56px;
        flex-shrink: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .mini-artwork-ring svg {
        position: absolute;
        inset: 0;
        transform: rotate(-90deg);
        pointer-events: none;
      }
      .mini-artwork-ring circle {
        fill: none;
        stroke: rgba(255, 215, 0, 0.25);
        stroke-width: 4;
      }
      .mini-artwork-ring circle.progress {
        stroke: #f6c453;
        stroke-linecap: round;
        stroke-dasharray: 157;
        stroke-dashoffset: 157;
        filter: drop-shadow(0 0 4px rgba(246, 196, 83, 0.6));
        transition: stroke-dashoffset 0.4s linear;
      }
      .mini-artwork {
        width: 46px;
        height: 46px;
        border-radius: 50%;
        overflow: hidden;
        position: relative;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
        z-index: 1;
      }
      .mini-artwork img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      /* removed .mini-progress-bar */

      .mini-artwork img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .mini-info {
        flex: 1;
        min-width: 0;
      }

      .mini-title {
        font-weight: 600;
        font-size: 13px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin-bottom: 2px;
      }

      .mini-artist {
        color: rgba(255, 255, 255, 0.7);
        font-size: 11px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        display: none; /* keep capsule compact */
      }

      .mini-controls {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .mini-btn {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.16);
        color: white;
        cursor: pointer;
        padding: 6px;
        border-radius: 999px;
        transition: all 0.25s ease;
      }

      .mini-btn:hover {
        transform: scale(1.06);
        background: rgba(255, 255, 255, 0.16);
      }

      /* Full Player */
      .full-player {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          135deg,
          var(--km-bg-start),
          var(--km-bg-end)
        );
        z-index: 2000;
        display: flex;
        flex-direction: column;
        transform: translateY(100%);
        transition: transform 0.4s ease, box-shadow 0.6s ease;
      }
      /* Apply glow only when full player is both active (visible) and playing to avoid footer glow bleed */
      .full-player.active.playing {
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.1) inset,
          0 0 80px -10px var(--km-accent-alt), 0 0 140px -20px var(--km-accent);
      }

      .full-player.active {
        transform: translateY(0);
      }

      .full-player-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px;
        padding-top: env(safe-area-inset-top, 20px);
        position: relative;
      }

      .full-player-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      /* removed stacked radial pseudo-element backgrounds in favor of dynamic tri-color gradient */
      .full-artwork-wrapper {
        width: 72%;
        max-width: 420px;
        aspect-ratio: 1/1;
        margin: 20px auto 20px;
        position: relative;
        border-radius: 38px;
        padding: 14px;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.12),
          rgba(255, 255, 255, 0.04)
        );
        backdrop-filter: blur(18px) saturate(140%);
        box-shadow: 0 30px 60px -20px rgba(0, 0, 0, 0.6),
          0 0 0 1px rgba(255, 255, 255, 0.12) inset;
      }
      .full-artwork-wrapper::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        padding: 2px;
        background: linear-gradient(
          120deg,
          var(--km-accent-alt),
          var(--km-accent)
        );
        -webkit-mask: linear-gradient(#000 0 0) content-box,
          linear-gradient(#000 0 0);
        mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
        -webkit-mask-composite: xor;
        mask-composite: exclude;
        opacity: 0.65;
      }
      .full-artwork-wrapper img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 26px;
        display: block;
      }
      .full-meta {
        text-align: center;
        padding: 0 22px 15px;
      }
      .full-meta .full-title {
        font-size: 20px;
        font-weight: 700;
        margin-bottom: 6px;
      }
      .full-meta .full-artist {
        font-size: 14px;
        opacity: 0.75;
        letter-spacing: 0.5px;
      }

      /* Premium header buttons (Back/Menu) */
      .back-btn,
      .more-btn {
        -webkit-appearance: none;
        appearance: none;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 42px;
        height: 42px;
        padding: 0;
        border-radius: 14px;
        color: #fff;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.28);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        cursor: pointer;
        transition: transform 0.22s ease, box-shadow 0.22s ease,
          background 0.3s ease, border-color 0.3s ease;
      }

      .back-btn:hover,
      .more-btn:hover {
        background: rgba(255, 255, 255, 0.12);
        transform: translateY(-1px) scale(1.03);
        box-shadow: 0 14px 30px rgba(0, 0, 0, 0.35);
        border-color: rgba(246, 196, 83, 0.35);
      }

      .back-btn:active,
      .more-btn:active {
        transform: translateY(0) scale(0.98);
      }

      /* Tweak icon size for header buttons */
      .full-player-header .icon {
        width: 22px;
        height: 22px;
      }

      .full-player-title {
        font-weight: 600;
        font-size: 16px;
      }

      /* Full-player swipe hints */
      .swipe-hint {
        position: absolute;
        inset: 0;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.16s ease;
        display: flex;
        align-items: center;
        z-index: 5;
      }
      .swipe-hint-left {
        justify-content: flex-start;
        background: radial-gradient(
          120px 220px at 0% 50%,
          rgba(246, 196, 83, 0.22),
          rgba(106, 13, 173, 0.18) 40%,
          rgba(0, 0, 0, 0) 60%
        );
      }
      .swipe-hint-right {
        justify-content: flex-end;
        background: radial-gradient(
          120px 220px at 100% 50%,
          rgba(246, 196, 83, 0.22),
          rgba(106, 13, 173, 0.18) 40%,
          rgba(0, 0, 0, 0) 60%
        );
      }
      .swipe-hint .hint-content {
        transition: transform 0.16s ease;
      }
      .hint-badge {
        background: rgba(0, 0, 0, 0.38);
        border: 1px solid rgba(246, 196, 83, 0.45);
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.28),
          0 0 0 1px rgba(255, 255, 255, 0.06) inset;
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        color: #fff;
        font-weight: 700;
        font-size: 12px;
        padding: 6px 10px;
        border-radius: 999px;
        margin: 0 18px;
      }

      /* Full Artwork */
      .full-artwork-container {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }

      .full-artwork {
        width: 280px;
        height: 280px;
        border-radius: 20px;
        overflow: hidden;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      }

      .full-artwork img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      /* Full Info */
      .full-info {
        padding: 0 30px 20px;
        text-align: center;
      }

      .full-title {
        font-size: 22px;
        font-weight: 700;
        margin-bottom: 8px;
      }

      .full-artist {
        color: rgba(255, 255, 255, 0.7);
        font-size: 16px;
      }

      /* Progress Container */
      .full-progress-container {
        padding: 0 30px 25px;
      }

      .progress-bar {
        height: 4px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 2px;
        margin-bottom: 15px;
        position: relative;
        cursor: pointer;
      }

      .progress-current {
        height: 100%;
        background: #f6c453;
        border-radius: 2px;
        width: 0%;
        transition: width 0.1s linear;
        box-shadow: 0 0 6px #f6c453b0, 0 0 2px #f6c453 inset;
      }

      .progress-handle {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        width: 16px;
        height: 16px;
        background: white;
        border-radius: 50%;
        left: 0%;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .progress-bar:hover .progress-handle,
      .progress-bar.dragging .progress-handle,
      .progress-bar.playing .progress-handle {
        opacity: 1;
      }

      .time-display {
        display: flex;
        justify-content: space-between;
        color: rgba(255, 255, 255, 0.7);
        font-size: 14px;
      }

      /* Full Controls */
      .full-controls {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 22px;
        padding: 0 30px 30px;
      }

      .control-btn {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        color: white;
        cursor: pointer;
        padding: 14px;
        border-radius: 16px;
        transition: transform 0.22s ease, box-shadow 0.22s ease,
          background 0.3s ease, border-color 0.3s ease;
        position: relative;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.28);
      }

      .control-btn:hover {
        background: rgba(255, 255, 255, 0.12);
        transform: translateY(-2px) scale(1.03);
        box-shadow: 0 14px 30px rgba(0, 0, 0, 0.35);
      }
      .control-btn:active {
        transform: translateY(0) scale(0.98);
      }

      .control-btn.primary {
        background: linear-gradient(135deg, #f6c453, #6a0dad);
        border: 1px solid rgba(246, 196, 83, 0.35);
        box-shadow: 0 14px 36px rgba(106, 13, 173, 0.35),
          0 0 0 1px rgba(0, 0, 0, 0.15) inset;
        font-size: 32px;
        padding: 18px;
        border-radius: 18px;
      }

      .control-btn.primary:hover {
        background: linear-gradient(135deg, #ffd88a, #7d1bd6);
        box-shadow: 0 18px 44px rgba(106, 13, 173, 0.45),
          0 0 0 1px rgba(0, 0, 0, 0.12) inset;
      }

      /* Active state for toggles (e.g., shuffle) */
      .control-btn.active {
        background: linear-gradient(
          135deg,
          rgba(246, 196, 83, 0.16),
          rgba(106, 13, 173, 0.14)
        );
        border-color: rgba(246, 196, 83, 0.45);
        box-shadow: 0 0 0 1px rgba(246, 196, 83, 0.25) inset,
          0 12px 28px rgba(246, 196, 83, 0.1);
      }

      /* Repeat one badge */
      #repeatBtn.repeat-one::after {
        content: "1";
        position: absolute;
        right: 10px;
        bottom: 10px;
        width: 14px;
        height: 14px;
        font-size: 10px;
        line-height: 14px;
        text-align: center;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.85);
        color: #000;
      }

      /* Record Button */
      .record-btn {
        color: #ff4757;
        transition: all 0.3s ease;
      }
      .record-btn:hover {
        background: rgba(255, 71, 87, 0.15);
        transform: scale(1.05);
      }
      .record-btn.recording {
        color: #ff3742;
        background: rgba(255, 71, 87, 0.2);
        animation: pulse 1.5s infinite;
      }
      .record-btn.recording .icon {
        animation: recordPulse 1s infinite;
      }
      @keyframes pulse {
        0%,
        100% {
          box-shadow: 0 0 0 0 rgba(255, 71, 87, 0.4);
        }
        50% {
          box-shadow: 0 0 0 10px rgba(255, 71, 87, 0);
        }
      }
      @keyframes recordPulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      /* Recording Status Indicator */
      .recording-status {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(255, 71, 87, 0.95);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        z-index: 2000;
        display: none;
        backdrop-filter: blur(10px);
      }
      .recording-status.show {
        display: block;
        animation: slideIn 0.3s ease;
      }
      @keyframes slideIn {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      /* Volume Container */
      .volume-container {
        display: flex;
        align-items: center;
        gap: 15px;
        padding: 0 30px 25px;
      }

      .volume-icon {
        color: rgba(255, 255, 255, 0.7);
      }

      .volume-slider {
        flex: 1;
        height: 4px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 2px;
        position: relative;
        cursor: pointer;
      }

      .volume-level {
        height: 100%;
        background: linear-gradient(45deg, #f6c453, #6a0dad);
        border-radius: 2px;
        width: 70%;
        transition: width 0.1s linear;
      }

      .volume-handle {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        width: 16px;
        height: 16px;
        background: white;
        border-radius: 50%;
        left: 70%;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .volume-slider:hover .volume-handle,
      .volume-slider.dragging .volume-handle {
        opacity: 1;
      }

      /* Loading Animation */
      .loading {
        text-align: center;
        padding: 40px 20px;
        color: rgba(255, 255, 255, 0.7);
      }

      .loading::after {
        content: "";
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top: 2px solid #f6c453;
        animation: spin 1s linear infinite;
        margin-left: 10px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Mobile Optimizations */
      @media (max-width: 480px) {
        .app-title {
          font-size: 24px;
        }

        .full-artwork {
          width: 240px;
          height: 240px;
        }

        .full-title {
          font-size: 20px;
        }

        .full-artist {
          font-size: 14px;
        }

        .control-btn {
          font-size: 24px;
          padding: 12px;
        }

        .control-btn.primary {
          font-size: 28px;
          padding: 15px;
        }
      }

      /* Dark scrollbar */
      ::-webkit-scrollbar {
        width: 8px;
      }

      ::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
      }

      ::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 10px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.5);
      }

      /* Footer Capsule Nav - Animated Sliding Design */
      .footer-nav-wrap {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0; /* stick to bottom of screen */
        padding-bottom: max(8px, env(safe-area-inset-bottom)); /* respect safe area with minimum padding */
        display: flex;
        justify-content: center;
        z-index: 900; /* below mini player */
        pointer-events: none; /* allow inner to capture */
      }

      .footer-nav {
        pointer-events: auto;
        position: relative;
        display: flex;
        gap: 0;
        /* Glassmorphism background - darker with transparency */
        background: rgba(15, 25, 40, 0.4);
        border: 1.5px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(30px) saturate(150%);
        -webkit-backdrop-filter: blur(30px) saturate(150%);
        border-radius: 999px;
        padding: 8px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6),
          0 0 0 1px rgba(255, 255, 255, 0.08) inset,
          0 4px 12px rgba(106, 13, 173, 0.15);
        max-width: 560px;
        width: calc(100% - 32px);
        overflow: hidden;
      }

      /* Animated background indicator - Glassmorphic sliding pill with subtle glow */
      .footer-nav::before {
        content: "";
        position: absolute;
        top: 8px;
        left: 8px;
        width: calc(33.333% - 5.33px);
        height: calc(100% - 16px);
        /* Glass effect with gradient */
        background: linear-gradient(
          135deg,
          rgba(79, 70, 229, 0.35) 0%,
          rgba(106, 13, 173, 0.3) 50%,
          rgba(59, 130, 246, 0.25) 100%
        );
        border: 1.5px solid rgba(255, 255, 255, 0.2);
        border-radius: 999px;
        transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        /* Subtle settled glow (like image 1) */
        box-shadow: 0 0 8px rgba(106, 13, 173, 0.25),
          0 0 15px rgba(79, 70, 229, 0.2), 0 8px 20px rgba(0, 0, 0, 0.3),
          0 0 0 1px rgba(255, 255, 255, 0.25) inset,
          inset 0 1px 0 rgba(255, 255, 255, 0.3);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        z-index: 0;
        pointer-events: none;
      }

      /* Trigger glow animation when transitioning */
      .footer-nav.transitioning::before {
        animation: pulse-glow 0.5s ease-in-out;
      }

      /* Strong glow animation during movement */
      @keyframes pulse-glow {
        0% {
          box-shadow: 0 0 8px rgba(106, 13, 173, 0.25),
            0 0 15px rgba(79, 70, 229, 0.2), 0 8px 20px rgba(0, 0, 0, 0.3),
            0 0 0 1px rgba(255, 255, 255, 0.25) inset,
            inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }
        50% {
          box-shadow: 0 0 35px rgba(106, 13, 173, 0.8),
            0 0 60px rgba(79, 70, 229, 0.6), 0 10px 30px rgba(0, 0, 0, 0.4),
            0 0 0 1px rgba(255, 255, 255, 0.4) inset,
            inset 0 1px 0 rgba(255, 255, 255, 0.5);
        }
        100% {
          box-shadow: 0 0 8px rgba(106, 13, 173, 0.25),
            0 0 15px rgba(79, 70, 229, 0.2), 0 8px 20px rgba(0, 0, 0, 0.3),
            0 0 0 1px rgba(255, 255, 255, 0.25) inset,
            inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }
      }

      /* Position indicator based on active button */
      .footer-nav[data-active="0"]::before {
        transform: translateX(0);
      }

      .footer-nav[data-active="1"]::before {
        transform: translateX(calc(100% + 4px));
      }

      .footer-nav[data-active="2"]::before {
        transform: translateX(calc(200% + 8px));
      }

      .footer-btn {
        flex: 1;
        position: relative;
        z-index: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 4px;
        padding: 12px 16px;
        border: none;
        background: transparent;
        color: rgba(255, 255, 255, 0.5);
        border-radius: 999px;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        font-size: 12px;
        font-weight: 500;
        white-space: nowrap;
        min-width: 0;
      }

      .footer-btn .icon {
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      .footer-btn .icon svg {
        width: 24px;
        height: 24px;
        transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      .footer-btn span:not(.icon) {
        transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        opacity: 0.8;
      }

      /* Active state */
      .footer-btn.active {
        background: transparent;
        color: #fff;
        transform: scale(1.02);
      }

      .footer-btn.active .icon {
        transform: scale(1.15);
      }

      .footer-btn.active .icon svg {
        filter: drop-shadow(0 0 12px rgba(140, 200, 255, 0.8))
          drop-shadow(0 0 6px rgba(106, 13, 173, 0.6));
      }

      .footer-btn.active span:not(.icon) {
        opacity: 1;
        font-weight: 600;
        text-shadow: 0 0 15px rgba(140, 200, 255, 0.5),
          0 0 8px rgba(106, 13, 173, 0.4);
      }

      /* Hover effect for non-active buttons */
      .footer-btn:not(.active):hover {
        color: rgba(255, 255, 255, 0.8);
        transform: translateY(-1px);
      }

      .footer-btn:not(.active):hover .icon svg {
        transform: scale(1.05);
      }

      /* Active button press animation */
      .footer-btn:active {
        transform: scale(0.98);
      }

      /* Responsive: smaller screens */
      @media (max-width: 400px) {
        .footer-nav {
          padding: 5px;
        }

        .footer-btn {
          padding: 10px 12px;
          font-size: 11px;
          gap: 3px;
        }

        .footer-btn .icon svg {
          width: 22px;
          height: 22px;
        }
      }

      /* Sections toggling */
      .tab-section {
        display: none;
        padding-bottom: 20px; /* extra padding at bottom of each section */
      }
      .tab-section.active {
        display: block;
      }

      /* Result action buttons */
      .result-actions {
        display: flex;
        gap: 8px;
        margin-left: 10px;
        flex-shrink: 0;
      }

      .icon-btn {
        width: 36px;
        height: 36px;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        border: none;
        background: rgba(255, 255, 255, 0.08);
        color: #fff;
        cursor: pointer;
        transition: transform 0.2s ease, background 0.2s ease;
      }

      .icon-btn:hover {
        transform: scale(1.05);
        background: rgba(255, 255, 255, 0.15);
      }
      .icon-btn.heart.active {
        background: rgba(246, 196, 83, 0.28);
        color: #ffd88a;
      }

      /* Favorites & Playlists lists */
      .list-empty {
        text-align: center;
        padding: 40px 20px;
        color: rgba(255, 255, 255, 0.7);
      }
      .list-empty .empty-icon {
        font-size: 48px;
        margin-bottom: 16px;
        opacity: 0.5;
      }
      .list-empty h3 {
        margin: 0 0 8px 0;
        font-size: 18px;
        font-weight: 600;
      }
      .list-empty p {
        margin: 0;
        font-size: 14px;
        opacity: 0.8;
        line-height: 1.4;
      }

      /* Recordings Section */
      .recordings-info {
        display: flex;
        gap: 12px;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.6);
      }
      .recording-item {
        display: flex;
        align-items: center;
        padding: 12px;
        margin: 8px 0;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      .recording-item:hover {
        background: rgba(255, 255, 255, 0.1);
        transform: translateY(-1px);
      }
      .recording-artwork {
        width: 50px;
        height: 50px;
        border-radius: 8px;
        background: linear-gradient(
          135deg,
          var(--km-accent),
          var(--km-accent-alt)
        );
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 600;
        margin-right: 12px;
      }
      .recording-info {
        flex: 1;
        min-width: 0;
      }
      .recording-title {
        font-weight: 600;
        font-size: 14px;
        color: white;
        margin-bottom: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .recording-meta {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.6);
        display: flex;
        gap: 8px;
      }
      .recording-actions {
        display: flex;
        gap: 8px;
      }
      .recording-btn {
        width: 32px;
        height: 32px;
        border: none;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.8);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }
      .recording-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        color: white;
      }
      .recording-btn.delete:hover {
        background: rgba(255, 71, 87, 0.2);
        color: #ff4757;
      }
      .section-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin: 10px 0 12px;
      }

      .recordings-controls {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .recordings-info {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 13px;
        color: #888;
      }
      .playlist-detail-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin: 10px 0 12px;
      }
      .playlist-detail-header .playlist-detail-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .section-title {
        font-size: 18px;
        font-weight: 600;
      }
      .pill-btn {
        border: none;
        padding: 10px 14px;
        border-radius: 999px;
        background: linear-gradient(45deg, #f6c453, #6a0dad);
        color: #fff;
        cursor: pointer;
        font-weight: 600;
      }
      .pill-btn.secondary {
        background: rgba(246, 196, 83, 0.15);
      }

      /* Danger variant for destructive actions */
      .pill-btn.danger {
        background: rgba(255, 77, 77, 0.16);
        color: #ffb3b3;
        border: 1px solid rgba(255, 77, 77, 0.35);
      }

      .playlist-item {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        justify-content: flex-start;
        padding: 14px;
        margin: 10px 0;
        border-radius: 16px;
        background: linear-gradient(
          135deg,
          rgba(106, 13, 173, 0.18),
          rgba(246, 196, 83, 0.12)
        );
        border: 1px solid rgba(246, 196, 83, 0.18);
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.28);
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease,
          background 0.3s ease;
      }
      .playlist-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 14px 30px rgba(0, 0, 0, 0.38);
        background: linear-gradient(
          135deg,
          rgba(106, 13, 173, 0.24),
          rgba(246, 196, 83, 0.16)
        );
      }
      .playlist-thumb-stack {
        position: relative;
        height: 64px;
        width: 200px; /* enough to show overlap */
        margin-bottom: 10px;
      }
      .playlist-thumb-stack img {
        position: absolute;
        top: 0;
        width: 64px;
        height: 64px;
        object-fit: cover;
        border-radius: 10px;
        border: 2px solid rgba(0, 0, 0, 0.35);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35),
          0 0 0 1px rgba(246, 196, 83, 0.18) inset;
      }
      .playlist-card-info {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
        gap: 10px;
      }
      .playlist-chip {
        display: inline-block;
        padding: 4px 10px;
        border-radius: 999px;
        background: rgba(246, 196, 83, 0.16);
        border: 1px solid rgba(246, 196, 83, 0.28);
        color: #ffd88a;
        font-size: 12px;
        font-weight: 600;
        margin-top: 4px;
      }
      .playlist-name {
        font-weight: 600;
        font-size: 16px;
      }
      .playlist-count {
        display: none;
      }
      .playlist-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .icon-btn.small {
        width: 32px;
        height: 32px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.1);
      }

      .playlist-detail-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin: 6px 0 12px;
      }
      .playlist-detail-actions {
        margin-left: auto;
        display: flex;
        gap: 8px;
      }
      .link-btn {
        background: none;
        border: none;
        color: #f6c453;
        font-weight: 600;
        cursor: pointer;
      }

      button:focus {
        outline: none;
      }
      button:focus-visible {
        outline: 2px solid rgba(255, 255, 255, 0.25);
        outline-offset: 2px;
        border-radius: 12px;
      }

      /* Simple overlay modal */
      .overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.5);
        display: none;
        align-items: flex-end;
        justify-content: center;
        z-index: 2500;
      }
      .sheet {
        width: 100%;
        max-width: 560px;
        background: rgba(26, 26, 26, 0.98);
        border-top-left-radius: 16px;
        border-top-right-radius: 16px;
        padding: 16px;
        box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.4);
      }
      .sheet-title {
        font-weight: 700;
        margin-bottom: 10px;
      }
      .sheet-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 10px;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.06);
        margin: 8px 0;
      }
      .sheet-row:hover {
        background: rgba(255, 255, 255, 0.1);
      }
      .sheet-actions {
        display: flex;
        gap: 8px;
      }
      .sheet-input {
        width: 100%;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 12px;
        color: #fff;
        padding: 12px 14px;
        font-size: 16px;
        margin: 8px 0 12px;
      }
      /* SVG icon style */
      .icon {
        width: 20px;
        height: 20px;
        fill: currentColor;
        display: block;
      }
      .header-btn .icon {
        width: 18px;
        height: 18px;
      }
      .search-button .icon {
        width: 20px;
        height: 20px;
      }
      .mini-btn .icon {
        width: 24px;
        height: 24px;
      }
      .control-btn .icon {
        width: 26px;
        height: 26px;
      }
      .footer-btn .icon .icon {
        width: 18px;
        height: 18px;
      }
      .volume-icon .icon {
        width: 18px;
        height: 18px;
      }
      .visually-hidden {
        position: absolute !important;
        height: 1px;
        width: 1px;
        overflow: hidden;
        clip: rect(1px, 1px, 1px, 1px);
        white-space: nowrap;
      }

      /* Desktop Pomodoro Studio */
      .pomodoro-panel {
        --pom-progress: 0deg;
        --pom-primary: #f6c453;
        --pom-secondary: #6a0dad;
        --pom-highlight: rgba(246, 196, 83, 0.18);
        --pom-border-accent: rgba(246, 196, 83, 0.32);
        --pom-shadow: rgba(246, 196, 83, 0.45);
        --pom-shadow-soft: rgba(246, 196, 83, 0.5);
        position: fixed;
        top: clamp(92px, 13vh, 170px);
        right: clamp(18px, 5vw, 68px);
        width: min(380px, 32vw);
        border-radius: var(--km-radius-lg);
        padding: 2px;
        background: linear-gradient(
          150deg,
          rgba(246, 196, 83, 0.55),
          rgba(106, 13, 173, 0.45)
        );
        box-shadow: 0 20px 60px -25px rgba(0, 0, 0, 0.45),
          0 24px 56px -30px rgba(106, 13, 173, 0.55);
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transform: translate3d(60px, 26px, 0) scale(0.94);
        transition: opacity 0.55s ease,
          transform 0.65s cubic-bezier(0.16, 1, 0.3, 1), box-shadow 0.6s ease;
        z-index: 2000;
      }
      .pomodoro-panel.active {
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
        transform: translate3d(0, 0, 0) scale(1);
        box-shadow: 0 35px 90px -35px rgba(0, 0, 0, 0.55),
          0 26px 64px -30px var(--pom-shadow-soft);
      }
      .pomodoro-close {
        display: none;
        position: absolute;
        top: 45px;
        right: 12px;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        cursor: pointer;
        z-index: 10;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        color: rgba(255, 255, 255, 0.9);
        font-size: 20px;
        line-height: 1;
      }
      .pomodoro-close:hover {
        background: rgba(0, 0, 0, 0.5);
        border-color: rgba(255, 255, 255, 0.3);
        transform: scale(1.05);
      }
      .pomodoro-close:active {
        transform: scale(0.95);
      }
      @media (min-width: 1024px) {
        .pomodoro-close {
          display: none !important;
        }
      }
      .pomodoro-glow {
        position: absolute;
        inset: -25%;
        border-radius: inherit;
        background: radial-gradient(
            circle at 25% 15%,
            rgba(246, 196, 83, 0.65),
            transparent 55%
          ),
          radial-gradient(
            circle at 80% 85%,
            rgba(106, 13, 173, 0.6),
            transparent 60%
          );
        filter: blur(38px);
        opacity: 0.7;
        animation: pomodoroGlow 12s ease-in-out infinite alternate;
        pointer-events: none;
      }
      .pomodoro-panel:not(.active) .pomodoro-glow {
        animation-play-state: paused;
      }
      .pomodoro-content {
        position: relative;
        border-radius: inherit;
        padding: clamp(24px, 3vw, 32px);
        background: radial-gradient(
            circle at 12% 6%,
            rgba(246, 196, 83, 0.18),
            transparent 58%
          ),
          radial-gradient(
            circle at 85% 120%,
            rgba(106, 13, 173, 0.22),
            transparent 60%
          ),
          linear-gradient(160deg, rgba(19, 11, 35, 0.92), rgba(32, 16, 58, 0.9));
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(26px) saturate(160%);
        -webkit-backdrop-filter: blur(26px) saturate(160%);
        overflow: hidden;
      }
      .pomodoro-content::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.08),
          rgba(255, 255, 255, 0)
        );
        opacity: 0.55;
        mix-blend-mode: screen;
        pointer-events: none;
      }
      .pomodoro-top {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 18px;
      }
      .pomodoro-heading {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .pomodoro-heading h2 {
        margin: 0;
        font-size: clamp(22px, 2vw, 26px);
        letter-spacing: 0.6px;
      }
      .pomodoro-kicker {
        font-size: 0.75rem;
        letter-spacing: 1.6px;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.62);
      }
      .pomodoro-subtitle {
        margin: 12px 0 24px;
        font-size: 0.9rem;
        line-height: 1.5;
        color: rgba(255, 255, 255, 0.7);
        max-width: 30ch;
      }
      .pomodoro-mode-switch {
        display: inline-flex;
        gap: 8px;
        padding: 6px;
        border-radius: 18px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.28);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        align-items: center;
        flex-shrink: 0;
      }
      .mode-option {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 8px 16px;
        border-radius: 12px;
        border: none;
        background: transparent;
        color: rgba(255, 255, 255, 0.7);
        font-weight: 600;
        font-size: 0.8rem;
        letter-spacing: 0.5px;
        cursor: pointer;
        transition: background 0.3s ease, color 0.3s ease, transform 0.25s ease;
      }
      .mode-option:hover {
        transform: translateY(-1px);
      }
      .mode-option.active {
        background: rgba(255, 255, 255, 0.16);
        color: #fff;
        box-shadow: 0 12px 24px -14px var(--pom-shadow);
      }
      .pomodoro-progress {
        display: flex;
        align-items: center;
        gap: clamp(20px, 3vw, 32px);
      }
      .pomodoro-ring {
        position: relative;
        width: clamp(195px, 20vw, 240px);
        aspect-ratio: 1 / 1;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: radial-gradient(
          circle at 50% 50%,
          rgba(255, 255, 255, 0.14),
          rgba(255, 255, 255, 0.05) 72%
        );
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08),
          0 18px 40px -18px var(--pom-shadow);
      }
      .pomodoro-ring::before {
        content: "";
        position: absolute;
        inset: 4px;
        border-radius: inherit;
        background: conic-gradient(
          from -90deg,
          var(--pom-primary) var(--pom-progress),
          rgba(255, 255, 255, 0.08) 0
        );
        filter: drop-shadow(0 0 30px var(--pom-shadow));
        transition: background 0.6s ease;
      }
      .pomodoro-ring::after {
        content: "";
        position: absolute;
        inset: clamp(16px, 1.6vw, 22px);
        border-radius: inherit;
        background: rgba(15, 7, 28, 0.78);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
      }
      .pomodoro-ring-core {
        position: relative;
        z-index: 2;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        text-align: center;
      }
      .pomodoro-mode {
        font-size: 0.8rem;
        font-weight: 600;
        letter-spacing: 1.4px;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.65);
      }
      .pomodoro-time {
        font-size: clamp(32px, 4vw, 44px);
        font-weight: 700;
        letter-spacing: 0.8px;
      }
      .pomodoro-phase-hint {
        font-size: 0.75rem;
        color: rgba(255, 255, 255, 0.6);
      }
      .pomodoro-stats {
        flex: 1;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
        gap: 12px;
      }
      .pomodoro-stat {
        border-radius: 18px;
        padding: 14px 16px;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
        backdrop-filter: blur(14px);
        transition: transform 0.35s ease, background 0.35s ease,
          border-color 0.35s ease;
      }
      .pomodoro-stat:hover {
        transform: translateY(-4px);
        background: var(--pom-highlight);
        border-color: var(--pom-border-accent);
      }
      .pomodoro-stat .label {
        display: block;
        font-size: 0.7rem;
        letter-spacing: 1.2px;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.58);
        margin-bottom: 6px;
      }
      .pomodoro-stat .value {
        font-size: 1.05rem;
        font-weight: 600;
      }
      .pomodoro-sliders {
        margin-top: 26px;
        display: grid;
        gap: 18px;
      }
      .pomodoro-slider {
        display: grid;
        gap: 10px;
      }
      .pomodoro-slider .slider-label {
        font-weight: 600;
        font-size: 0.85rem;
        color: rgba(255, 255, 255, 0.74);
        letter-spacing: 0.3px;
      }
      .pomodoro-slider input[type="range"] {
        appearance: none;
        -webkit-appearance: none;
        width: 100%;
        height: 6px;
        border-radius: 999px;
        background: linear-gradient(
          90deg,
          var(--pom-primary),
          var(--pom-secondary)
        );
        outline: none;
      }
      .pomodoro-slider input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #fff;
        border: 2px solid rgba(9, 1, 17, 0.85);
        box-shadow: 0 6px 16px rgba(246, 196, 83, 0.45);
        cursor: pointer;
        transition: transform 0.2s ease;
      }
      .pomodoro-slider input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #fff;
        border: 2px solid rgba(9, 1, 17, 0.85);
        box-shadow: 0 6px 16px rgba(246, 196, 83, 0.45);
        cursor: pointer;
        transition: transform 0.2s ease;
      }
      .pomodoro-slider input[type="range"]::-webkit-slider-thumb:hover,
      .pomodoro-slider input[type="range"]::-moz-range-thumb:hover {
        transform: scale(1.1);
      }
      .pomodoro-slider .slider-value {
        font-size: 0.8rem;
        color: rgba(255, 255, 255, 0.64);
      }
      .pomodoro-actions {
        margin-top: 26px;
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }
      .pomodoro-action {
        flex: 1;
        min-width: 110px;
        height: 48px;
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(255, 255, 255, 0.08);
        color: #fff;
        font-weight: 600;
        font-size: 0.95rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: transform 0.3s ease, box-shadow 0.3s ease,
          background 0.3s ease, border-color 0.3s ease;
      }
      .pomodoro-action.primary {
        background: linear-gradient(
          120deg,
          var(--pom-primary),
          var(--pom-secondary)
        );
        border-color: var(--pom-border-accent);
        box-shadow: 0 18px 30px -16px var(--pom-shadow);
      }
      .pomodoro-action.ghost {
        background: rgba(255, 255, 255, 0.05);
      }
      .pomodoro-action:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 20px 34px -18px var(--pom-shadow);
      }
      .pomodoro-action:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
      }
      .pomodoro-panel.mode-transition .pomodoro-ring::before {
        filter: drop-shadow(0 0 38px var(--pom-shadow));
      }
      .pomodoro-panel.mode-transition .pomodoro-content::before {
        opacity: 0.75;
      }
      @media (max-width: 1440px) {
        .pomodoro-progress {
          flex-direction: column;
          align-items: stretch;
        }
        .pomodoro-stats {
          width: 100%;
          grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        }
      }
      @media (max-width: 1023px) {
        .pomodoro-panel {
          /* Compact modal on mobile - no scrolling needed */
          top: 50%;
          left: 50%;
          right: auto;
          bottom: auto;
          transform: translate(-50%, -50%);
          width: calc(100% - 32px);
          max-width: 450px;
          height: auto;
          max-height: calc(100vh - 40px);
          border-radius: 24px;
          padding: 0;
          background: linear-gradient(
            150deg,
            rgba(246, 196, 83, 0.25),
            rgba(106, 13, 173, 0.25)
          );
          backdrop-filter: blur(20px);
          -webkit-backdrop-filter: blur(20px);
        }
        
        .pomodoro-panel.active {
          transform: translate(-50%, -50%) scale(1);
        }
        
        .pomodoro-content {
          padding: 20px;
          padding-top: 16px;
          padding-bottom: 20px;
          height: auto;
          overflow-y: auto;
          max-height: calc(100vh - 40px);
        }
        
        .pomodoro-top {
          margin-bottom: 16px;
        }
        
        .pomodoro-heading h2 {
          font-size: 24px;
        }
        
        .pomodoro-kicker {
          font-size: 11px;
        }
        
        .pomodoro-subtitle {
          font-size: 13px;
          margin-bottom: 16px;
        }
        
        .pomodoro-progress {
          margin-bottom: 16px;
        }
        
        .pomodoro-ring {
          width: 220px;
          height: 220px;
        }
        
        .pomodoro-time {
          font-size: 42px;
        }
        
        .pomodoro-mode {
          font-size: 13px;
        }
        
        .pomodoro-phase-hint {
          font-size: 11px;
        }
        
        .pomodoro-stats {
          grid-template-columns: 1fr 1fr;
          gap: 10px;
        }
        
        .pomodoro-stat {
          padding: 12px;
        }
        
        .pomodoro-sliders {
          gap: 12px;
          margin-bottom: 16px;
        }
        
        .pomodoro-actions {
          gap: 10px;
          flex-direction: row;
        }
        
        .pomodoro-action {
          flex: 1;
          padding: 14px;
          font-size: 14px;
        }
        
        .pomodoro-action.ghost {
          display: none; /* Hide reset button on mobile to save space */
        }
      }
      @keyframes pomodoroGlow {
        0% {
          transform: scale(0.96) translate3d(0, 0, 0);
          opacity: 0.6;
        }
        50% {
          transform: scale(1) translate3d(4px, -4px, 0);
          opacity: 0.75;
        }
        100% {
          transform: scale(0.98) translate3d(-3px, 3px, 0);
          opacity: 0.65;
        }
      }
      @media (prefers-reduced-motion: reduce) {
        .pomodoro-panel,
        .pomodoro-action,
        .pomodoro-slider input[type="range"]::-webkit-slider-thumb,
        .pomodoro-slider input[type="range"]::-moz-range-thumb {
          transition: none !important;
        }
        .pomodoro-glow {
          animation: none;
        }
      }

      /* QR Code Modal */
      .qr-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 3000;
        backdrop-filter: blur(10px);
      }
      .qr-modal.show {
        display: flex;
      }
      .qr-modal-content {
        background: linear-gradient(
          145deg,
          rgba(26, 26, 26, 0.95),
          rgba(40, 40, 40, 0.9)
        );
        backdrop-filter: blur(20px);
        border-radius: 20px;
        padding: 30px;
        text-align: center;
        max-width: 300px;
        width: 90%;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      }
      .qr-modal h3 {
        margin: 0 0 20px 0;
        color: var(--km-accent-alt);
        font-size: 18px;
        font-weight: 600;
      }
      .qr-code-container {
        background: white;
        border-radius: 12px;
        padding: 15px;
        margin: 0 auto 20px;
        display: inline-block;
      }
      .qr-modal p {
        margin: 0 0 20px 0;
        color: rgba(255, 255, 255, 0.8);
        font-size: 14px;
        line-height: 1.4;
      }
      .qr-close-btn {
        background: linear-gradient(135deg, var(--km-accent), #8a2be2);
        border: none;
        border-radius: 12px;
        color: white;
        padding: 12px 24px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease;
      }
      .qr-close-btn:hover {
        transform: scale(1.05);
      }

      #playlistDetailTitle[contenteditable="true"] {
        outline: 2px solid rgba(246, 196, 83, 0.5);
        border-radius: 8px;
        padding: 2px 6px;
        background: rgba(255, 255, 255, 0.08);
      }
      .swipe-gradient-hint {
        position: fixed;
        top: 0;
        bottom: 0;
        width: 140px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.18s ease;
        z-index: 1200;
      }
      .swipe-gradient-hint.left {
        left: 0;
        background: linear-gradient(
          90deg,
          rgba(246, 196, 83, 0.25),
          rgba(106, 13, 173, 0)
        );
      }
      .swipe-gradient-hint.right {
        right: 0;
        background: linear-gradient(
          270deg,
          rgba(246, 196, 83, 0.25),
          rgba(106, 13, 173, 0)
        );
      }
      .swipe-gradient-hint .hint-label {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        color: #fff;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 0.5px;
        background: rgba(0, 0, 0, 0.35);
        padding: 6px 10px;
        border-radius: 999px;
        backdrop-filter: blur(6px);
        -webkit-backdrop-filter: blur(6px);
      }
      .swipe-gradient-hint.left .hint-label {
        left: 12px;
      }
      .swipe-gradient-hint.right .hint-label {
        right: 12px;
      }

      /* Floating AI Button */
      .ai-float-btn {
        position: fixed;
        bottom: 90px;
        right: 20px;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        border: none;
        background: linear-gradient(135deg, #f6c453 0%, #6a0dad 100%);
        box-shadow: 0 8px 24px rgba(106, 13, 173, 0.4),
          0 4px 12px rgba(246, 196, 83, 0.3),
          inset 0 1px 0 rgba(255, 255, 255, 0.2);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 950;
        transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        animation: aiFloat 3s ease-in-out infinite;
      }
      .ai-float-btn::before {
        content: "";
        position: absolute;
        inset: -3px;
        border-radius: 50%;
        background: linear-gradient(135deg, #f6c453, #6a0dad);
        opacity: 0;
        filter: blur(12px);
        transition: opacity 0.3s ease;
        z-index: -1;
      }
      .ai-float-btn:hover::before {
        opacity: 0.8;
      }
      .ai-float-btn:hover {
        transform: scale(1.15) rotate(8deg);
        box-shadow: 0 12px 36px rgba(106, 13, 173, 0.6),
          0 6px 18px rgba(246, 196, 83, 0.5),
          inset 0 1px 0 rgba(255, 255, 255, 0.3);
      }
      .ai-float-btn:active {
        transform: scale(1.05);
      }
      .ai-float-btn .icon {
        width: 28px;
        height: 28px;
        color: white;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
      }
      @keyframes aiFloat {
        0%,
        100% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-8px);
        }
      }
      @media (max-width: 768px) {
        .ai-float-btn {
          bottom: 85px;
          right: 16px;
          width: 56px;
          height: 56px;
        }
        .ai-float-btn .icon {
          width: 26px;
          height: 26px;
        }
      }

      /* AI Playlist Generator Modal - Pomodoro Style */
      .ai-playlist-modal {
        --ai-primary: #f6c453;
        --ai-secondary: #6a0dad;
        --ai-shadow: rgba(246, 196, 83, 0.45);
        --ai-shadow-soft: rgba(106, 13, 173, 0.45);
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.75);
        z-index: 3000;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(16px);
        -webkit-backdrop-filter: blur(16px);
        padding: 20px;
      }
      .ai-playlist-modal.show {
        display: flex;
        animation: fadeIn 0.3s ease;
      }
      .ai-modal-content {
        position: relative;
        background: transparent;
        border-radius: 32px;
        padding: 0;
        max-width: 560px;
        width: 100%;
        max-height: 90vh;
        overflow: visible;
        box-shadow: 0 35px 90px -35px rgba(0, 0, 0, 0.55),
          0 26px 64px -30px var(--ai-shadow-soft);
        transform: scale(0.95);
        opacity: 0;
        transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
      }
      .ai-playlist-modal.show .ai-modal-content {
        transform: scale(1);
        opacity: 1;
      }
      .ai-modal-glow {
        position: absolute;
        inset: -20%;
        border-radius: inherit;
        background: radial-gradient(
            circle at 25% 15%,
            rgba(246, 196, 83, 0.65),
            transparent 55%
          ),
          radial-gradient(
            circle at 80% 85%,
            rgba(106, 13, 173, 0.6),
            transparent 60%
          );
        filter: blur(38px);
        opacity: 0.7;
        animation: pomodoroGlow 12s ease-in-out infinite alternate;
        pointer-events: none;
        z-index: -1;
      }
      .ai-modal-inner {
        position: relative;
        border-radius: inherit;
        padding: clamp(28px, 4vw, 36px);
        background: radial-gradient(
            circle at 12% 6%,
            rgba(246, 196, 83, 0.18),
            transparent 58%
          ),
          radial-gradient(
            circle at 85% 120%,
            rgba(106, 13, 173, 0.22),
            transparent 60%
          ),
          linear-gradient(160deg, rgba(19, 11, 35, 0.92), rgba(32, 16, 58, 0.9));
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(26px) saturate(160%);
        -webkit-backdrop-filter: blur(26px) saturate(160%);
        overflow-y: auto;
        max-height: 90vh;
        min-height: 500px;
      }
      .ai-modal-inner.vinyl-mode {
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .ai-modal-inner::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.08),
          rgba(255, 255, 255, 0)
        );
        opacity: 0.55;
        mix-blend-mode: screen;
        pointer-events: none;
      }
      .ai-modal-header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 16px;
        margin-bottom: 24px;
        position: relative;
        z-index: 1;
      }
      .ai-modal-heading {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .ai-modal-kicker {
        font-size: 0.75rem;
        letter-spacing: 1.6px;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.62);
      }
      .ai-modal-header h2 {
        margin: 0;
        font-size: clamp(22px, 3vw, 28px);
        letter-spacing: 0.6px;
        font-weight: 700;
        color: #fff;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .ai-modal-header .icon {
        filter: drop-shadow(0 4px 12px var(--ai-shadow));
      }
      .ai-close-btn {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.12);
        width: 40px;
        height: 40px;
        border-radius: 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        flex-shrink: 0;
      }
      .ai-close-btn:hover {
        background: rgba(255, 255, 255, 0.16);
        border-color: rgba(255, 255, 255, 0.2);
        transform: scale(1.05);
      }
      .ai-input-group {
        margin-bottom: 20px;
        position: relative;
        z-index: 1;
      }
      .ai-input-group label {
        display: block;
        margin-bottom: 10px;
        font-size: 0.85rem;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.74);
        letter-spacing: 0.3px;
      }
      .ai-input-group input,
      .ai-input-group textarea {
        width: 100%;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 16px;
        padding: 14px 18px;
        color: white;
        font-size: 15px;
        font-family: inherit;
        outline: none;
        transition: all 0.35s ease;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
        backdrop-filter: blur(14px);
      }
      .ai-input-group textarea {
        resize: vertical;
        min-height: 110px;
        line-height: 1.6;
      }
      .ai-input-group input:focus,
      .ai-input-group textarea:focus {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(246, 196, 83, 0.4);
        box-shadow: 0 0 0 3px rgba(246, 196, 83, 0.12),
          inset 0 0 0 1px rgba(246, 196, 83, 0.08);
        transform: translateY(-1px);
      }
      .ai-input-group input::placeholder,
      .ai-input-group textarea::placeholder {
        color: rgba(255, 255, 255, 0.45);
      }
      .ai-input-hint {
        font-size: 0.75rem;
        color: rgba(255, 255, 255, 0.6);
        margin-top: 8px;
        margin-bottom: 8px;
      }
      .ai-generate-btn {
        width: 100%;
        background: linear-gradient(
          135deg,
          var(--ai-primary),
          var(--ai-secondary)
        );
        border: none;
        border-radius: 16px;
        padding: 18px;
        color: white;
        font-size: 16px;
        font-weight: 700;
        letter-spacing: 0.5px;
        cursor: pointer;
        transition: all 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        box-shadow: 0 8px 24px rgba(246, 196, 83, 0.3),
          0 4px 12px rgba(106, 13, 173, 0.2);
        position: relative;
        z-index: 1;
        overflow: hidden;
      }
      .ai-generate-btn::before {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.2),
          rgba(255, 255, 255, 0)
        );
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .ai-generate-btn:hover:not(:disabled)::before {
        opacity: 1;
      }
      .ai-generate-btn:hover:not(:disabled) {
        transform: translateY(-3px);
        box-shadow: 0 12px 32px rgba(246, 196, 83, 0.45),
          0 6px 16px rgba(106, 13, 173, 0.3);
      }
      .ai-generate-btn:active:not(:disabled) {
        transform: translateY(-1px);
      }
      .ai-generate-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }
      .ai-status {
        margin-top: 20px;
        padding: 16px 18px;
        border-radius: 16px;
        font-size: 14px;
        display: none;
        position: relative;
        z-index: 1;
        backdrop-filter: blur(14px);
        line-height: 1.5;
      }
      .ai-status.show {
        display: block;
      }
      .ai-status.loading {
        background: rgba(106, 13, 173, 0.15);
        border: 1px solid rgba(106, 13, 173, 0.3);
        color: #e0b3ff;
      }
      .ai-status.success {
        background: rgba(46, 213, 115, 0.15);
        border: 1px solid rgba(46, 213, 115, 0.3);
        color: #a8ffcf;
      }
      .ai-status.error {
        background: rgba(255, 71, 87, 0.15);
        border: 1px solid rgba(255, 71, 87, 0.3);
        color: #ffb3ba;
      }
      .ai-progress {
        margin-top: 12px;
      }
      .ai-progress-bar {
        height: 8px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 999px;
        overflow: hidden;
        margin-top: 8px;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
      }
      .ai-progress-fill {
        height: 100%;
        background: linear-gradient(
          90deg,
          var(--ai-primary),
          var(--ai-secondary)
        );
        border-radius: 999px;
        width: 0%;
        transition: width 0.3s ease;
        box-shadow: 0 0 12px rgba(246, 196, 83, 0.4);
      }
      .ai-examples {
        margin-top: 12px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .ai-example-chip {
        display: inline-flex;
        align-items: center;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 20px;
        padding: 8px 14px;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
        backdrop-filter: blur(12px);
      }
      .ai-example-chip:hover {
        background: rgba(246, 196, 83, 0.15);
        border-color: rgba(246, 196, 83, 0.3);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(246, 196, 83, 0.2);
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
      @media (max-width: 768px) {
        .ai-modal-content {
          max-width: calc(100vw - 32px);
        }
      }

      /* Vinyl Record Loader Animation */
      .vinyl-loader {
        display: none;
        position: absolute;
        inset: -28px;
        background: radial-gradient(
            circle at 12% 6%,
            rgba(246, 196, 83, 0.18),
            transparent 58%
          ),
          radial-gradient(
            circle at 85% 120%,
            rgba(106, 13, 173, 0.22),
            transparent 60%
          ),
          linear-gradient(160deg, rgba(19, 11, 35, 0.92), rgba(32, 16, 58, 0.9));
        border-radius: 32px;
        z-index: 100;
        opacity: 0;
        transition: opacity 0.3s ease;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      .vinyl-loader.active {
        display: flex !important;
        opacity: 1;
      }
      .vinyl-stage {
        position: relative;
        width: 100%;
        max-width: 500px;
        height: 450px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .orbit-container {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        animation: orbitRotate 20s linear infinite;
      }
      .orbit-container.pause-orbit {
        animation-play-state: paused;
      }
      .center-vinyl {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10;
        transform-origin: center center;
      }
      .vinyl-disc {
        width: 160px;
        height: 160px;
        border-radius: 50%;
        background: radial-gradient(
            circle at center,
            #1a1a1a 0%,
            #0a0a0a 30%,
            #1a1a1a 31%,
            #0f0f0f 32%,
            #1a1a1a 33%,
            #000 100%
          ),
          conic-gradient(
            from 0deg,
            rgba(255, 255, 255, 0.03) 0deg,
            transparent 10deg,
            rgba(255, 255, 255, 0.03) 20deg,
            transparent 30deg
          );
        position: relative;
        box-shadow: 0 12px 36px rgba(0, 0, 0, 0.6),
          inset 0 0 0 1px rgba(255, 255, 255, 0.05);
      }
      .vinyl-disc.spinning {
        animation: vinylSpin 3s linear infinite;
      }
      .vinyl-disc.spinning-slow {
        animation: vinylSpin 4s linear infinite;
      }
      .vinyl-center {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: radial-gradient(
          circle at 30% 30%,
          rgba(246, 196, 83, 0.9),
          rgba(106, 13, 173, 0.7)
        );
        box-shadow: 0 0 30px rgba(246, 196, 83, 0.6),
          inset 0 2px 6px rgba(255, 255, 255, 0.3);
      }
      .vinyl-center::after {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #0a0a0a;
        box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.8);
      }
      .vinyl-grooves {
        position: absolute;
        inset: 0;
        border-radius: 50%;
        background: repeating-radial-gradient(
          circle at center,
          transparent 0px,
          transparent 1px,
          rgba(255, 255, 255, 0.02) 1px,
          rgba(255, 255, 255, 0.02) 2px
        );
      }
      .orbiting-record {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 80px;
        height: 80px;
        margin: -40px 0 0 -40px;
        transform: translate(var(--orbit-x, 0), var(--orbit-y, 0)) scale(0);
        opacity: 0;
        animation: orbitAppear 0.8s ease forwards;
      }
      .orbiting-record.fly-to-center {
        animation: flyToCenter 0.8s ease-in forwards !important;
      }
      .orbiting-record-inner {
        width: 100%;
        height: 100%;
        border-radius: 50%;
        position: relative;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
        overflow: hidden;
        transition: transform 0.3s ease;
      }
      .orbiting-record:hover .orbiting-record-inner {
        transform: scale(1.05);
      }
      .orbiting-record img {
        width: 100%;
        height: 100%;
        border-radius: 50%;
        object-fit: cover;
      }
      .orbiting-record::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 50%;
        background: radial-gradient(
          circle at center,
          rgba(0, 0, 0, 0.85) 22%,
          transparent 22%,
          transparent 100%
        );
        pointer-events: none;
        z-index: 1;
      }
      .vinyl-status-text {
        margin-top: 20px;
        font-size: 20px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.9);
        text-align: center;
        letter-spacing: 0.5px;
        background: linear-gradient(135deg, #f6c453, #6a0dad);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: textPulse 2s ease-in-out infinite;
      }
      @keyframes vinylSpin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }
      @keyframes recordAppear {
        from {
          transform: translateY(-20px) scale(0.8);
          opacity: 0;
        }
        to {
          transform: translateY(0) scale(0.9);
          opacity: 1;
        }
      }
      @keyframes orbitAppear {
        from {
          opacity: 0;
          transform: translate(var(--orbit-x, 0), var(--orbit-y, 0)) scale(0.2);
        }
        to {
          opacity: 1;
          transform: translate(var(--orbit-x, 0), var(--orbit-y, 0)) scale(1);
        }
      }
      @keyframes orbitAppearOld {
        from {
          opacity: 0;
          transform: scale(0.3);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }
      @keyframes textPulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }
      @keyframes orbitRotate {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }
      @keyframes flyToCenter {
        0% {
          opacity: 1;
          transform: translate(var(--orbit-x, 0), var(--orbit-y, 0)) scale(1);
        }
        100% {
          opacity: 0;
          transform: translate(0, 0) scale(0.2);
        }
      }
      @keyframes centerZoomIn {
        0% {
          transform: translate(-50%, -50%) scale(1);
        }
        100% {
          transform: translate(-50%, -50%) scale(3);
        }
      }
      @keyframes fadeInComplete {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .center-vinyl.zoom-complete {
        animation: centerZoomIn 1.2s ease-out forwards;
      }
      /* Hide form elements when vinyl is active */
      .ai-modal-inner.vinyl-mode .ai-input-group,
      .ai-modal-inner.vinyl-mode .ai-generate-btn,
      .ai-modal-inner.vinyl-mode .ai-status,
      .ai-modal-inner.vinyl-mode .ai-modal-header {
        display: none;
      }
      @media (max-width: 768px) {
        .vinyl-stage {
          max-width: 350px;
          height: 350px;
        }
        .vinyl-disc {
          width: 120px;
          height: 120px;
        }
        .orbiting-record {
          width: 70px;
          height: 70px;
          margin: -35px 0 0 -35px;
        }
        .vinyl-status-text {
          font-size: 16px;
        }
      }
    </style>
  </head>

  <body>
    <div class="bg-orbs" aria-hidden="true">
      <div class="orb"></div>
      <div class="orb alt"></div>
      <div class="orb third"></div>
    </div>
    <!-- SVG sprite definitions for icons (paths via inline SVG + mask) -->
    <svg
      width="0"
      height="0"
      style="position: absolute"
      xmlns:xlink="http://www.w3.org/1999/xlink"
    >
      <defs>
        <symbol id="ic-search" viewBox="0 0 24 24">
          <path
            fill="currentColor"
            d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5m-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14Z"
          />
        </symbol>
        <symbol id="ic-heart" viewBox="0 0 24 24">
          <path
            fill="currentColor"
            d="M12.1 8.64L12 8.77l-.1-.13C10.14 6.6 7.1 6.24 5.28 8.09c-1.82 1.86-1.46 4.89.73 6.77L12 20l5.99-5.14c2.19-1.88 2.55-4.91.73-6.77-1.82-1.85-4.86-1.49-6.62.55Z"
          />
        </symbol>
        <symbol id="ic-heart-fill" viewBox="0 0 24 24">
          <path
            fill="currentColor"
            d="M12.1 18.55L12 18.65l-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C14.46 5.99 15.96 5 17.5 5 19.5 5 21 6.5 21 8.5c0 2.89-3.14 5.74-8.9 10.05Z"
          />
        </symbol>
        <symbol id="ic-plus" viewBox="0 0 24 24">
          <path fill="currentColor" d="M19 13H13v6h-2v-6H5v-2h6V5h2v6h6v2Z" />
        </symbol>
        <symbol id="ic-trash" viewBox="0 0 24 24">
          <path
            fill="currentColor"
            d="M9 3h6l1 1h4v2H4V4h4l1-1m1 6h2v9h-2V9m-4 0h2v9H7V9m8 0h2v9h-2V9Z"
          />
        </symbol>
        <symbol id="ic-play" viewBox="0 0 24 24">
          <path fill="currentColor" d="M8 5.14v14l11-7-11-7Z" />
        </symbol>
        <symbol id="ic-pause" viewBox="0 0 24 24">
          <path fill="currentColor" d="M14 19h4V5h-4v14M6 19h4V5H6v14Z" />
        </symbol>
        <symbol id="ic-prev" viewBox="0 0 24 24">
          <path fill="currentColor" d="M6 18V6h2v12H6m3.5-6 8.5 6V6l-8.5 6Z" />
        </symbol>
        <symbol id="ic-next" viewBox="0 0 24 24">
          <path fill="currentColor" d="M6 6v12l8.5-6L6 6m10 0h2v12h-2V6Z" />
        </symbol>
        <symbol id="ic-shuffle" viewBox="0 0 24 24">
          <path
            fill="currentColor"
            d="M14.59 9H16V7l3 3-3 3v-2h-1.41l-2 2H8v-2h2.17l2.42-2.42M16 17h-1.41l-1.88-1.88 1.41-1.41L16 14.59V13l3 3-3 3v-2m-8-8H4V8h4v1Z"
          />
        </symbol>
        <symbol id="ic-repeat" viewBox="0 0 24 24">
          <path
            fill="currentColor"
            d="M17 17H7v-3l-4 4 4 4v-3h12a3 3 0 0 0 3-3V7h-2v8a2 2 0 0 1-2 2M7 7h10v3l4-4-4-4v3H5a3 3 0 0 0-3 3v8h2V9a2 2 0 0 1 2-2Z"
          />
        </symbol>
        <symbol id="ic-back" viewBox="0 0 24 24">
          <path
            fill="currentColor"
            d="M20 12H7.83l5.59-5.59L12 5l-8 8 8 8 1.41-1.41L7.83 13H20v-1Z"
          />
        </symbol>
        <symbol id="ic-more" viewBox="0 0 24 24">
          <path
            fill="currentColor"
            d="M12 16a2 2 0 1 1 0 4 2 2 0 0 1 0-4m0-6a2 2 0 1 1 0 4 2 2 0 0 1 0-4m0-6a2 2 0 1 1 0 4 2 2 0 0 1 0-4Z"
          />
        </symbol>
        <symbol id="ic-volume" viewBox="0 0 24 24">
          <path
            fill="currentColor"
            d="M14 3.23v17.54L7.77 15H3V9h4.77L14 3.23M16.5 12c0-1.77-1.02-3.29-2.5-4.03v8.06c1.48-.74 2.5-2.26 2.5-4.03Z"
          />
        </symbol>
        <symbol id="ic-settings" viewBox="0 0 24 24">
          <path
            fill="currentColor"
            d="M12 8a4 4 0 1 1 0 8 4 4 0 0 1 0-8m8.94 3.34-1.62-.94.12-1.86-1.8-.72-.9 1.62-1.74-.45-.9-1.62-1.8.72.12 1.86-1.62.94-1.62-.94-.12-1.86-1.8.72.9 1.62-1.74.45-.9-1.62-1.8.72.12 1.86-1.62.94 1.04 1.69 1.86-.12.94 1.62-1.62.94 1.04 1.69 1.86-.12.94 1.62 1.8-.72-.12-1.86 1.62-.94 1.62.94.12 1.86 1.8-.72-.9-1.62 1.74-.45.9 1.62 1.8-.72-.12-1.86 1.62-.94-1.04-1.69Z"
          />
        </symbol>
        <symbol id="ic-rain" viewBox="0 0 24 24">
          <!-- Simple raindrop icon -->
          <path
            fill="currentColor"
            d="M12 2C9.2 7 6 10.3 6 13.5A6 6 0 0 0 18 13.5C18 10.3 14.8 7 12 2Z"
          />
        </symbol>
        <symbol id="ic-library" viewBox="0 0 24 24">
          <path
            fill="currentColor"
            d="M4 5h16v2H4V5m0 4h10v2H4V9m0 4h16v2H4v-2m0 4h10v2H4v-2Z"
          />
        </symbol>
        <symbol id="ic-record" viewBox="0 0 24 24">
          <circle cx="12" cy="12" r="8" fill="currentColor" />
        </symbol>
        <symbol id="ic-record-stop" viewBox="0 0 24 24">
          <rect x="6" y="6" width="12" height="12" rx="2" fill="currentColor" />
        </symbol>
        <symbol id="ic-download" viewBox="0 0 24 24">
          <path
            fill="currentColor"
            d="M12 16l-4-4h3V4h2v8h3l-4 4m-6 2h12v2H6v-2Z"
          />
        </symbol>
        <symbol id="ic-close" viewBox="0 0 24 24">
          <path
            fill="currentColor"
            d="m19 6.41-1.41-1.41L12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12Z"
          />
        </symbol>
        <symbol id="ic-pomodoro" viewBox="0 0 24 24">
          <path
            fill="currentColor"
            d="M15 1H9v2h6V1m-3 4a8 8 0 1 0 8 8 8 8 0 0 0-8-8Zm0 14a6 6 0 1 1 6-6 6 6 0 0 1-6 6Zm-.5-10v4.25l3.5 2.08.75-1.23-2.75-1.6V9Z"
          />
        </symbol>
        <symbol id="ic-ai-sparkle" viewBox="0 0 24 24">
          <path
            fill="currentColor"
            d="M12 2l2.4 7.2h7.6l-6 4.8 2.4 7.2-6-4.8-6 4.8 2.4-7.2-6-4.8h7.6L12 2m0 5.5L11 10h2l-1-2.5M7 14l1.5 1-1 1.5 1.5-1 1 1.5-1-1.5 1.5-1H8l1-1.5L8 14H7m10 0l1.5 1-1 1.5 1.5-1 1 1.5-1-1.5 1.5-1h-1.5l1-1.5-1 1.5H17Z"
          />
        </symbol>
      </defs>
    </svg>
    <!-- YouTube IFrame for Music Playback -->
    <div
      id="youtube-player"
      style="position: absolute; top: -9999px; left: -9999px"
    ></div>

    <!-- Recording Status Indicator -->
    <div id="recordingStatus" class="recording-status">
       Recording... <span id="recordingTimer">0:00</span>
      <button
        id="forceStopBtn"
        onclick="forceStopScreenRecording()"
        style="
          margin-left: 10px;
          padding: 2px 6px;
          font-size: 10px;
          background: #ff4444;
          color: white;
          border: none;
          border-radius: 3px;
          cursor: pointer;
        "
      >
        Force Stop
      </button>
    </div>

    <!-- Main App Container -->
    <div class="app-container">
      <div class="swipe-gradient-hint left" id="swipeHintEdgeLeft">
        <span class="hint-label">Back / Prev</span>
      </div>
      <div class="swipe-gradient-hint right" id="swipeHintEdgeRight">
        <span class="hint-label">Next</span>
      </div>
      <!-- Header -->
      <header class="app-header">
        <h1 class="app-title">KwikMusic</h1>
        <div class="header-icons">
          <button
            class="header-btn"
            id="recordingsBtn"
            aria-label="My Recordings"
            title="My Recordings"
          >
            <svg class="icon"><use href="#ic-download" /></svg>
          </button>
          <button
            class="header-btn"
            id="pomodoroBtn"
            aria-label="Focus Timer"
            title="Focus Timer"
          >
            <svg class="icon"><use href="#ic-pomodoro" /></svg>
          </button>
          <button
            class="header-btn"
            id="settingsBtn"
            aria-label="Rain"
            title="Rain: Off"
          >
            <svg class="icon"><use xlink:href="#ic-rain" /></svg>
          </button>
        </div>
      </header>

      <!-- Main Content Area -->
      <main class="main-content">
        <!-- Search Section (Tab 1) -->
        <section class="search-section tab-section active" id="tabSearch">
          <div class="search-container">
            <div class="search-box">
              <input
                type="text"
                id="searchInput"
                placeholder="Type to search..."
                autocomplete="off"
              />
              <button id="searchBtn" class="search-button">
                <svg class="icon" viewBox="0 0 24 24">
                  <use xlink:href="#ic-search" />
                </svg>
              </button>
            </div>
          </div>

          <!-- Suggestions from user's library (favorites + playlists) -->
          <div id="searchSuggestions" class="search-suggestions">
            <div class="section-header">
              <div class="section-title">From your library</div>
            </div>
            <div id="suggestionsList"></div>
          </div>

          <!-- Search Results -->
          <div class="search-results" id="searchResults">
            <div class="welcome-message">
              <h2>Welcome to KwikMusic</h2>
              <p>Find your next favorite track and start listening.</p>
            </div>
          </div>
        </section>

        <!-- Favorites Section (Tab 2) -->
        <section class="tab-section" id="tabFavorites">
          <div class="section-header">
            <div class="section-title">Favorites</div>
          </div>
          <div id="favoritesList"></div>
          <div id="favoritesEmpty" class="list-empty" style="display: none">
            No favorites yet. Tap the heart on a song to save it here.
          </div>
        </section>

        <!-- Playlists Section (Tab 3) -->
        <section class="tab-section" id="tabPlaylists">
          <div class="section-header">
            <div class="section-title">Playlists</div>
            <button id="newPlaylistBtn" class="pill-btn">New Playlist</button>
          </div>
          <div id="playlistsView">
            <div id="playlistsList"></div>
            <div id="playlistsEmpty" class="list-empty" style="display: none">
              No playlists yet. Create one and start adding songs.
            </div>
          </div>
          <div id="playlistDetail" style="display: none">
            <div class="playlist-detail-header">
              <button
                id="playlistBackBtn"
                class="link-btn"
                title="Back"
                aria-label="Back"
              >
                <svg class="icon"><use href="#ic-back" /></svg>
              </button>
              <div
                class="section-title"
                id="playlistDetailTitle"
                title="Click to rename"
              >
                Playlist
              </div>
              <div class="playlist-detail-actions">
                <button
                  id="playlistPlayAllBtn"
                  class="pill-btn secondary"
                  title="Play all"
                  aria-label="Play all"
                >
                  <svg class="icon"><use href="#ic-play" /></svg>
                </button>
                <button
                  id="playlistShuffleBtn"
                  class="pill-btn secondary"
                  title="Shuffle"
                  aria-label="Shuffle"
                >
                  <svg class="icon"><use href="#ic-shuffle" /></svg>
                </button>
                <button
                  id="playlistDeleteBtn"
                  class="pill-btn danger"
                  title="Delete playlist"
                  aria-label="Delete playlist"
                >
                  <svg class="icon"><use href="#ic-trash" /></svg>
                </button>
              </div>
            </div>
            <div id="playlistTracks"></div>
          </div>
        </section>

        <!-- Recordings Section (Tab 4) -->
        <section class="tab-section" id="tabRecordings">
          <div class="section-header">
            <div class="section-title">My Recordings</div>
            <div class="recordings-controls">
              <button
                class="control-btn"
                id="playAllRecordingsBtn"
                title="Play All Recordings"
                style="display: none"
              >
                <svg class="icon" width="20" height="20" viewBox="0 0 24 24">
                  <use href="#ic-play"></use>
                </svg>
              </button>
              <button
                class="control-btn"
                id="shuffleRecordingsBtn"
                title="Shuffle All Recordings"
                style="display: none"
              >
                <svg class="icon" width="20" height="20" viewBox="0 0 24 24">
                  <use href="#ic-shuffle"></use>
                </svg>
              </button>
            </div>
          </div>
          <div class="recordings-info">
            <span id="recordingsCount">0 recordings</span>
            <span id="recordingsSize">0 MB</span>
          </div>
          <div id="recordingsView">
            <div id="recordingsList"></div>
            <div id="recordingsEmpty" class="list-empty">
              <div class="empty-icon"></div>
              <h3>No recordings yet</h3>
              <p>
                Tap the record button while playing a song to save it for
                offline listening.
              </p>
            </div>
          </div>
        </section>
      </main>

      <!-- Floating AI Button -->
      <button
        class="ai-float-btn"
        id="aiPlaylistBtn"
        aria-label="AI Playlist Generator"
      >
        <svg class="icon" width="28" height="28">
          <use href="#ic-ai-sparkle"></use>
        </svg>
      </button>

      <!-- AI Playlist Generator Modal -->
      <div id="aiPlaylistModal" class="ai-playlist-modal">
        <div class="ai-modal-content">
          <div class="ai-modal-glow"></div>
          <div class="ai-modal-inner">
            <div class="ai-modal-header">
              <div class="ai-modal-heading">
                <span class="ai-modal-kicker">Powered by Gemini AI</span>
                <h2>
                  <svg class="icon" width="26" height="26">
                    <use href="#ic-ai-sparkle"></use>
                  </svg>
                  AI Playlist Studio
                </h2>
              </div>
              <button class="ai-close-btn" id="aiCloseBtn" aria-label="Close">
                <svg class="icon" width="20" height="20">
                  <use href="#ic-close"></use>
                </svg>
              </button>
            </div>

            <div class="ai-input-group">
              <label for="playlistPrompt">Describe your playlist</label>
              <textarea
                id="playlistPrompt"
                placeholder="e.g., Create a playlist of Arijit Singh songs from 2021 to 2022"
              ></textarea>
              <div class="ai-input-hint"> Try these quick examples:</div>
              <div class="ai-examples">
                <span
                  class="ai-example-chip"
                  data-prompt="Top 10 AR Rahman songs from the 2000s"
                  >AR Rahman 2000s hits</span
                >
                <span
                  class="ai-example-chip"
                  data-prompt="Relaxing lo-fi beats for studying"
                  >Lo-fi study music</span
                >
                <span
                  class="ai-example-chip"
                  data-prompt="Energetic workout songs with high tempo"
                  >Workout motivation</span
                >
                <span
                  class="ai-example-chip"
                  data-prompt="90s Bollywood romantic songs"
                  >90s Bollywood romance</span
                >
              </div>
            </div>

            <div class="ai-input-group">
              <label for="playlistName">Playlist Name (optional)</label>
              <input
                type="text"
                id="playlistName"
                placeholder="Auto-generated if left blank"
              />
            </div>

            <button class="ai-generate-btn" id="aiGenerateBtn">
              <svg class="icon" width="20" height="20">
                <use href="#ic-ai-sparkle"></use>
              </svg>
              Generate Playlist
            </button>

            <div class="ai-status" id="aiStatus">
              <div id="aiStatusMessage"></div>
              <div class="ai-progress" id="aiProgress" style="display: none">
                <div id="aiProgressText"></div>
                <div class="ai-progress-bar">
                  <div class="ai-progress-fill" id="aiProgressFill"></div>
                </div>
              </div>
            </div>

            <!-- Vinyl Record Loading Animation -->
            <div class="vinyl-loader" id="vinylLoader" style="display: none">
              <div class="vinyl-stage">
                <div class="orbit-container" id="orbitContainer">
                  <!-- Center vinyl disc -->
                  <div class="center-vinyl">
                    <div class="vinyl-disc spinning-slow">
                      <div class="vinyl-center"></div>
                      <div class="vinyl-grooves"></div>
                    </div>
                  </div>
                  <!-- Orbiting records will be added here dynamically -->
                </div>
              </div>
              <div class="vinyl-status-text" id="vinylStatusText">
                Curating your playlist...
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="pomodoroPanel" class="pomodoro-panel" aria-hidden="true">
        <button class="pomodoro-close" id="pomodoroCloseBtn" aria-label="Close Pomodoro"></button>
        <div class="pomodoro-glow"></div>
        <div class="pomodoro-content">
          <div class="pomodoro-top">
            <div class="pomodoro-heading">
              <span class="pomodoro-kicker">Productivity mode</span>
              <h2>Pomodoro Studio</h2>
            </div>
            <div
              class="pomodoro-mode-switch"
              role="radiogroup"
              aria-label="Pomodoro start mode"
            >
              <button
                type="button"
                class="mode-option active"
                data-mode="study"
                aria-pressed="true"
              >
                Study first
              </button>
              <button
                type="button"
                class="mode-option"
                data-mode="break"
                aria-pressed="false"
              >
                Break first
              </button>
            </div>
          </div>
          <p class="pomodoro-subtitle">
            Balance deep work bursts with mindful breaks to stay in flow.
          </p>
          <div class="pomodoro-progress">
            <div
              class="pomodoro-ring"
              role="progressbar"
              aria-valuemin="0"
              aria-valuemax="1"
              aria-valuenow="0"
            >
              <div class="pomodoro-ring-core">
                <span class="pomodoro-mode" id="pomodoroModeLabel">Study</span>
                <span class="pomodoro-time" id="pomodoroTime">25:00</span>
                <span class="pomodoro-phase-hint" id="pomodoroPhaseHint"
                  >Next: Break 5 min</span
                >
              </div>
            </div>
            <div class="pomodoro-stats">
              <div class="pomodoro-stat">
                <span class="label">Study</span>
                <span class="value"
                  ><span id="studyDurationDisplay">25</span> min</span
                >
              </div>
              <div class="pomodoro-stat">
                <span class="label">Break</span>
                <span class="value"
                  ><span id="breakDurationDisplay">5</span> min</span
                >
              </div>
            </div>
          </div>
          <div class="pomodoro-sliders">
            <label class="pomodoro-slider" for="studyDurationInput">
              <span class="slider-label">Study length</span>
              <input
                type="range"
                id="studyDurationInput"
                min="10"
                max="90"
                step="5"
                value="25"
              />
              <div class="slider-value">
                <span id="studyDurationLabel">25</span> minutes
              </div>
            </label>
            <label class="pomodoro-slider" for="breakDurationInput">
              <span class="slider-label">Break length</span>
              <input
                type="range"
                id="breakDurationInput"
                min="3"
                max="30"
                step="1"
                value="5"
              />
              <div class="slider-value">
                <span id="breakDurationLabel">5</span> minutes
              </div>
            </label>
          </div>
          <div class="pomodoro-actions">
            <button class="pomodoro-action primary" id="pomodoroStartBtn">
              Start
            </button>
            <button class="pomodoro-action" id="pomodoroPauseBtn" disabled>
              Pause
            </button>
            <button class="pomodoro-action ghost" id="pomodoroResetBtn">
              Reset
            </button>
          </div>
        </div>
      </div>

      <!-- Mini Player Bar (Bottom) -->
      <div class="mini-player" id="miniPlayer" style="display: none">
        <div class="mini-player-content" id="miniPlayerContent">
          <div class="mini-artwork-ring">
            <svg viewBox="0 0 54 54" width="54" height="54" aria-hidden="true">
              <circle cx="27" cy="27" r="25" class="track" />
              <circle
                cx="27"
                cy="27"
                r="25"
                class="progress"
                id="miniProgressCircle"
              />
            </svg>
            <div class="mini-artwork">
              <img id="miniArtwork" src="images/bg.png" alt="Now Playing" />
            </div>
          </div>
          <div class="mini-info">
            <div class="mini-title" id="miniTitle">No song selected</div>
            <div class="mini-artist" id="miniArtist">Select a song to play</div>
          </div>
          <div class="mini-controls">
            <button class="mini-btn" id="miniPlayPauseBtn">
              <svg class="icon"><use href="#ic-play" /></svg>
            </button>
          </div>
        </div>
      </div>

      <!-- Full Screen Player -->
      <div class="full-player" id="fullPlayer">
        <div class="full-player-header">
          <button class="back-btn" id="backBtn">
            <svg class="icon"><use href="#ic-back" /></svg>
          </button>
          <div class="full-player-title">Now Playing</div>
          <div class="full-player-actions">
            <button
              class="header-btn record-btn"
              id="recordBtn"
              title="Record for offline playback"
            >
              <svg class="icon"><use href="#ic-record" /></svg>
            </button>
            <button class="more-btn" id="moreBtn">
              <svg class="icon"><use href="#ic-more" /></svg>
            </button>
          </div>
        </div>

        <!-- Swipe hints overlay -->
        <div class="swipe-hint swipe-hint-left" id="swipeHintLeft">
          <div class="hint-content">
            <span class="hint-badge">Previous</span>
          </div>
        </div>
        <div class="swipe-hint swipe-hint-right" id="swipeHintRight">
          <div class="hint-content"><span class="hint-badge">Next</span></div>
        </div>

        <div class="full-artwork-wrapper">
          <img id="fullArtwork" src="images/bg.png" alt="Now Playing" />
        </div>

        <div class="full-info">
          <div class="full-title" id="fullTitle">No song selected</div>
          <div class="full-artist" id="fullArtist">Select a song to play</div>
        </div>

        <div class="full-progress-container">
          <div class="progress-bar" id="progressBar">
            <div class="progress-current" id="progressCurrent"></div>
            <div class="progress-handle" id="progressHandle"></div>
          </div>
          <div class="time-display">
            <span id="currentTime">0:00</span>
            <span id="totalTime">0:00</span>
          </div>
        </div>

        <div class="full-controls">
          <button class="control-btn" id="shuffleBtn">
            <svg class="icon"><use href="#ic-shuffle" /></svg>
          </button>
          <button class="control-btn" id="prevBtn">
            <svg class="icon"><use href="#ic-prev" /></svg>
          </button>
          <button class="control-btn primary" id="playPauseBtn">
            <svg class="icon"><use href="#ic-play" /></svg>
          </button>
          <button class="control-btn" id="nextBtn">
            <svg class="icon"><use href="#ic-next" /></svg>
          </button>
          <button class="control-btn" id="repeatBtn">
            <svg class="icon"><use href="#ic-repeat" /></svg>
          </button>
        </div>

        <div class="volume-container">
          <div class="volume-icon">
            <svg class="icon"><use href="#ic-volume" /></svg>
          </div>
          <div class="volume-slider" id="volumeSlider">
            <div class="volume-level" id="volumeLevel"></div>
            <div class="volume-handle" id="volumeHandle"></div>
          </div>
        </div>
      </div>

      <!-- Footer Capsule Nav -->
      <div class="footer-nav-wrap">
        <div class="footer-nav" role="tablist" data-active="0">
          <button class="footer-btn active" id="tabBtnSearch">
            <span class="icon"
              ><svg class="icon"><use href="#ic-search" /></svg></span
            ><span>Search</span>
          </button>
          <button class="footer-btn" id="tabBtnFavorites">
            <span class="icon"
              ><svg class="icon"><use href="#ic-heart" /></svg></span
            ><span>Favorites</span>
          </button>
          <button class="footer-btn" id="tabBtnPlaylists">
            <span class="icon"
              ><svg class="icon"><use href="#ic-library" /></svg></span
            ><span>Playlists</span>
          </button>
        </div>
      </div>
    </div>

    <!-- Overlays -->
    <div class="overlay" id="playlistOverlay">
      <div class="sheet">
        <div class="sheet-title">Add to playlist</div>
        <div id="playlistChoices"></div>
        <div class="sheet-actions" style="margin-top: 8px">
          <button class="pill-btn" id="createPlaylistInline">Create new</button>
          <button
            class="pill-btn"
            style="background: rgba(255, 255, 255, 0.12); color: #fff"
            id="closePlaylistOverlay"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <!-- Create Playlist Overlay (in-app) -->
    <div class="overlay" id="createPlaylistOverlay" style="display: none">
      <div class="sheet">
        <div class="sheet-title">Create playlist</div>
        <input
          id="playlistNameInput"
          class="sheet-input"
          type="text"
          placeholder="Playlist name"
          maxlength="80"
        />
        <div class="sheet-actions">
          <button class="pill-btn" id="confirmCreatePlaylist">Create</button>
          <button
            class="pill-btn"
            id="cancelCreatePlaylist"
            style="background: rgba(255, 255, 255, 0.12); color: #fff"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <script>
      // Register Service Worker for PWA functionality
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("sw.js")
            .then((registration) => {
              console.log("SW registered: ", registration);
            })
            .catch((registrationError) => {
              console.log("SW registration failed: ", registrationError);
            });

          // When a new SW takes control, do a one-time reload to get fresh app
          let swRefreshing = false;
          navigator.serviceWorker.addEventListener("controllerchange", () => {
            if (swRefreshing) return;
            swRefreshing = true;
            try {
              window.location.reload();
            } catch {}
          });
        });
      }

      // Offline Detection and Auto-Navigation
      function isOnline() {
        return navigator.onLine;
      }

      function handleOfflineMode() {
        if (!isOnline()) {
          console.log("App is offline, redirecting to recordings...");
          // Wait a bit for DOM to be ready then switch to recordings
          setTimeout(() => {
            if (typeof setActiveTab === "function") {
              setActiveTab("recordings");
            }
          }, 1000);
        }
      }

      // Listen for online/offline events
      window.addEventListener("online", () => {
        console.log("App is back online");
        // Could show a notification here
      });

      window.addEventListener("offline", () => {
        console.log("App went offline");
        handleOfflineMode();
      });

      // Ensure screen recording stops when page is closed/refreshed
      window.addEventListener("beforeunload", (event) => {
        if (isRecording && currentStream) {
          console.log("Page unloading - forcing screen recording cleanup");

          // Comprehensive track cleanup on page unload
          const tracks = currentStream.getTracks();
          tracks.forEach((track, index) => {
            track.onended = null;
            track.onmute = null;
            track.onunmute = null;
            track.stop();
            console.log(
              `Cleanup: Stopped track ${index + 1}/${tracks.length}: ${
                track.kind
              }`
            );
          });

          // Reset state
          currentStream = null;
          isRecording = false;

          if (mediaRecorder && mediaRecorder.state !== "inactive") {
            mediaRecorder.stop();
          }
          mediaRecorder = null;
        }
      });

      // Global variables
      let youtubePlayer;
      let currentYouTubeTrack = null;
      let currentSearchResults = [];
      let currentYouTubeIndex = -1;
      let youTubeProgressInterval = null;
      let isPlayerReady = false;

      // Recording queue system
      let currentRecordingQueue = [];
      let currentRecordingIndex = -1;
      let isPlayingRecordingQueue = false;

      // Playback modes
      // repeatMode: 'off' | 'all' | 'one'
      let repeatMode = "off";
      // Background/lockscreen handling
      let lastPauseByUser = false; // true when pause was explicitly requested by user (UI or media session)
      // Ambient rain
      let rainAudio = null;
      let isRainOn = false;
      let rainVolume = 0.35;
      // Background hidden-resume loop (Android reliability)
      let bgResumeTimer = null;
      let bgResumeTries = 0;
      let currentOpenPlaylistId = null; // track open playlist for rename
      // Track last non-search tab for back gesture from search
      let lastNonSearchTab = "favorites"; // default fallback

      // Recording System Variables
      let mediaRecorder = null;
      let recordedChunks = [];
      let isRecording = false;
      let recordingStartTime = 0;
      let recordingTimerInterval = null;
      let currentStream = null;
      const RECORDINGS_DB_NAME = "KwikMusicRecordings";
      const RECORDINGS_DB_VERSION = 1;
      let recordingsDB = null;

      // YouTube API Integration - Dual Key System with Automatic Fallback
      // INJECT_GEMINI_API_KEY
      // INJECT_YOUTUBE_API_KEYS
      let currentApiKeyIndex = 0;

      // Function to get current API key and switch on failure
      function getYouTubeApiKey() {
        return YOUTUBE_API_KEYS[currentApiKeyIndex];
      }

      function switchToNextApiKey() {
        currentApiKeyIndex = (currentApiKeyIndex + 1) % YOUTUBE_API_KEYS.length;
        console.log(` Switched to YouTube API key ${currentApiKeyIndex + 1}`);
        return getYouTubeApiKey();
      }

      // DOM Elements
      const searchInput = document.getElementById("searchInput");
      const searchBtn = document.getElementById("searchBtn");
      const searchResults = document.getElementById("searchResults");
      const miniPlayer = document.getElementById("miniPlayer");
      const fullPlayer = document.getElementById("fullPlayer");
      const miniPlayPauseBtn = document.getElementById("miniPlayPauseBtn");
      const playPauseBtn = document.getElementById("playPauseBtn");
      const prevBtn = document.getElementById("prevBtn");
      const nextBtn = document.getElementById("nextBtn");
      const backBtn = document.getElementById("backBtn");
      const progressBar = document.getElementById("progressBar");
      const progressCurrent = document.getElementById("progressCurrent");
      const progressHandle = document.getElementById("progressHandle");
      const volumeSlider = document.getElementById("volumeSlider");
      const volumeLevel = document.getElementById("volumeLevel");
      const volumeHandle = document.getElementById("volumeHandle");
      const currentTime = document.getElementById("currentTime");
      const totalTime = document.getElementById("totalTime");
      const rainToggleBtn = document.getElementById("settingsBtn");
      const searchSuggestions = document.getElementById("searchSuggestions");
      const suggestionsList = document.getElementById("suggestionsList");

      // Tabs
      const tabBtnSearch = document.getElementById("tabBtnSearch");
      const tabBtnFavorites = document.getElementById("tabBtnFavorites");
      const tabBtnPlaylists = document.getElementById("tabBtnPlaylists");
      const recordingsBtn = document.getElementById("recordingsBtn");
      const tabSearch = document.getElementById("tabSearch");
      const tabFavorites = document.getElementById("tabFavorites");
      const tabPlaylists = document.getElementById("tabPlaylists");
      const tabRecordings = document.getElementById("tabRecordings");

      // Recording DOM elements
      const recordBtn = document.getElementById("recordBtn");
      const recordingStatus = document.getElementById("recordingStatus");
      const recordingTimer = document.getElementById("recordingTimer");
      const recordingsList = document.getElementById("recordingsList");
      const recordingsEmpty = document.getElementById("recordingsEmpty");
      const recordingsCount = document.getElementById("recordingsCount");
      const recordingsSize = document.getElementById("recordingsSize");

      // Favorites/Playlists DOM
      const favoritesList = document.getElementById("favoritesList");
      const favoritesEmpty = document.getElementById("favoritesEmpty");
      const newPlaylistBtn = document.getElementById("newPlaylistBtn");
      const playlistsList = document.getElementById("playlistsList");
      const playlistsEmpty = document.getElementById("playlistsEmpty");
      const playlistDetail = document.getElementById("playlistDetail");
      const playlistBackBtn = document.getElementById("playlistBackBtn");
      const playlistDetailTitle = document.getElementById(
        "playlistDetailTitle"
      );
      const playlistTracks = document.getElementById("playlistTracks");
      const playlistPlayAllBtn = document.getElementById("playlistPlayAllBtn");
      const playlistShuffleBtn = document.getElementById("playlistShuffleBtn");

      // Overlay
      const playlistOverlay = document.getElementById("playlistOverlay");
      const closePlaylistOverlay = document.getElementById(
        "closePlaylistOverlay"
      );
      const playlistChoices = document.getElementById("playlistChoices");
      const createPlaylistInline = document.getElementById(
        "createPlaylistInline"
      );
      // Create Playlist overlay elements
      const createPlaylistOverlay = document.getElementById(
        "createPlaylistOverlay"
      );
      const playlistNameInput = document.getElementById("playlistNameInput");
      const confirmCreatePlaylist = document.getElementById(
        "confirmCreatePlaylist"
      );
      const cancelCreatePlaylist = document.getElementById(
        "cancelCreatePlaylist"
      );

      // Desktop Pomodoro timer setup
      (function setupPomodoroTimer() {
        const pomodoroBtn = document.getElementById("pomodoroBtn");
        const pomodoroPanel = document.getElementById("pomodoroPanel");
        if (!pomodoroBtn || !pomodoroPanel) return;

        const pomodoroModeLabel = document.getElementById("pomodoroModeLabel");
        const pomodoroTime = document.getElementById("pomodoroTime");
        const pomodoroPhaseHint = document.getElementById("pomodoroPhaseHint");
        const studyDurationInput =
          document.getElementById("studyDurationInput");
        const breakDurationInput =
          document.getElementById("breakDurationInput");
        const studyDurationLabel =
          document.getElementById("studyDurationLabel");
        const breakDurationLabel =
          document.getElementById("breakDurationLabel");
        const studyDurationDisplay = document.getElementById(
          "studyDurationDisplay"
        );
        const breakDurationDisplay = document.getElementById(
          "breakDurationDisplay"
        );
        const pomodoroStartBtn = document.getElementById("pomodoroStartBtn");
        const pomodoroPauseBtn = document.getElementById("pomodoroPauseBtn");
        const pomodoroResetBtn = document.getElementById("pomodoroResetBtn");
        const pomodoroRing = pomodoroPanel.querySelector(".pomodoro-ring");
        const modeOptions = pomodoroPanel.querySelectorAll(".mode-option");

        const STUDY_MIN = parseInt(studyDurationInput?.min || "10", 10);
        const STUDY_MAX = parseInt(studyDurationInput?.max || "90", 10);
        const BREAK_MIN = parseInt(breakDurationInput?.min || "3", 10);
        const BREAK_MAX = parseInt(breakDurationInput?.max || "30", 10);
        const SETTINGS_KEY = "kwikmusic_pomodoro_prefs";

        const modePalette = {
          study: {
            primary: "#f6c453",
            secondary: "#6a0dad",
            highlight: "rgba(246, 196, 83, 0.18)",
            border: "rgba(246, 196, 83, 0.32)",
            shadow: "rgba(246, 196, 83, 0.45)",
            shadowSoft: "rgba(246, 196, 83, 0.5)",
          },
          break: {
            primary: "#61e8e1",
            secondary: "#3f73ff",
            highlight: "rgba(97, 232, 225, 0.22)",
            border: "rgba(97, 232, 225, 0.32)",
            shadow: "rgba(97, 232, 225, 0.35)",
            shadowSoft: "rgba(97, 232, 225, 0.42)",
          },
        };

        const state = {
          mode: "study",
          startMode: "study",
          studyMinutes: 25,
          breakMinutes: 5,
          remainingSeconds: 25 * 60,
          totalSeconds: 25 * 60,
          running: false,
          startedOnce: false,
          preAlertPlayed: false,
          timerId: null,
          panelOpen: false,
          lastTickTime: null, // For accurate background timing
        };

        let timerAlertAudio = null;

        function clampValue(value, min, max) {
          return Math.max(min, Math.min(max, value));
        }

        function loadSettings() {
          try {
            const savedRaw = localStorage.getItem(SETTINGS_KEY);
            if (!savedRaw) return;
            const saved = JSON.parse(savedRaw);
            if (typeof saved?.study === "number") {
              state.studyMinutes = clampValue(
                saved.study,
                STUDY_MIN,
                STUDY_MAX
              );
            }
            if (typeof saved?.break === "number") {
              state.breakMinutes = clampValue(
                saved.break,
                BREAK_MIN,
                BREAK_MAX
              );
            }
            if (saved?.startMode === "break" || saved?.startMode === "study") {
              state.startMode = saved.startMode;
            }
          } catch (error) {
            console.warn("Failed to load pomodoro settings", error);
          }
        }

        function persistSettings() {
          try {
            localStorage.setItem(
              SETTINGS_KEY,
              JSON.stringify({
                study: state.studyMinutes,
                break: state.breakMinutes,
                startMode: state.startMode,
              })
            );
          } catch (error) {
            console.warn("Failed to persist pomodoro settings", error);
          }
        }

        loadSettings();
        state.mode = state.startMode;
        const initialMinutes =
          state.startMode === "break" ? state.breakMinutes : state.studyMinutes;
        state.totalSeconds = initialMinutes * 60;
        state.remainingSeconds = state.totalSeconds;
        state.preAlertPlayed = false;

        function applyPalette() {
          const palette = modePalette[state.mode] || modePalette.study;
          pomodoroPanel.style.setProperty("--pom-primary", palette.primary);
          pomodoroPanel.style.setProperty("--pom-secondary", palette.secondary);
          pomodoroPanel.style.setProperty("--pom-highlight", palette.highlight);
          pomodoroPanel.style.setProperty(
            "--pom-border-accent",
            palette.border
          );
          pomodoroPanel.style.setProperty("--pom-shadow", palette.shadow);
          pomodoroPanel.style.setProperty(
            "--pom-shadow-soft",
            palette.shadowSoft
          );
          pomodoroPanel.dataset.mode = state.mode;
        }

        function setProgress(ratio) {
          const bounded = Math.max(0, Math.min(1, ratio || 0));
          pomodoroPanel.style.setProperty(
            "--pom-progress",
            `${bounded * 360}deg`
          );
          if (pomodoroRing) {
            pomodoroRing.setAttribute("aria-valuenow", bounded.toFixed(2));
          }
        }

        function ensureTimerAlertAudio() {
          if (timerAlertAudio) return timerAlertAudio;
          try {
            timerAlertAudio = new Audio("timer.mp3");
            timerAlertAudio.preload = "auto";
            timerAlertAudio.volume = 0.75;
          } catch (error) {
            console.warn("Failed to initialise timer audio", error);
            timerAlertAudio = null;
          }
          return timerAlertAudio;
        }

        function resetPreAlertAudio() {
          if (!timerAlertAudio) return;
          try {
            timerAlertAudio.pause();
            timerAlertAudio.currentTime = 0;
          } catch (error) {
            console.warn("Failed to reset timer audio", error);
          }
        }

        function maybePlayPreAlert() {
          if (state.preAlertPlayed) return;
          if (!state.running) return;
          if (state.remainingSeconds > 15 || state.remainingSeconds <= 0)
            return;
          state.preAlertPlayed = true;
          const audio = ensureTimerAlertAudio();
          if (!audio) return;
          try {
            audio.currentTime = 0;
            const playPromise = audio.play();
            if (playPromise?.catch) {
              playPromise.catch(() => {});
            }
          } catch (error) {
            console.warn("Failed to play pre-alert audio", error);
          }
        }

        function updateModeSelector() {
          if (!modeOptions || modeOptions.length === 0) return;
          modeOptions.forEach((button) => {
            const isActive = button.dataset.mode === state.startMode;
            button.classList.toggle("active", isActive);
            button.setAttribute("aria-pressed", isActive ? "true" : "false");
          });
        }

        function updateDurationLabels() {
          if (studyDurationLabel)
            studyDurationLabel.textContent = state.studyMinutes;
          if (studyDurationDisplay)
            studyDurationDisplay.textContent = state.studyMinutes;
          if (breakDurationLabel)
            breakDurationLabel.textContent = state.breakMinutes;
          if (breakDurationDisplay)
            breakDurationDisplay.textContent = state.breakMinutes;
          if (studyDurationInput) studyDurationInput.value = state.studyMinutes;
          if (breakDurationInput) breakDurationInput.value = state.breakMinutes;
        }

        function updatePhaseHint() {
          if (!pomodoroPhaseHint) return;
          const nextLabel =
            state.mode === "study"
              ? `Next: Break ${state.breakMinutes} min`
              : `Next: Study ${state.studyMinutes} min`;
          pomodoroPhaseHint.textContent = nextLabel;
        }

        function updateTimeDisplay() {
          if (!pomodoroTime || !pomodoroModeLabel) return;
          pomodoroTime.textContent = formatTime(state.remainingSeconds);
          pomodoroModeLabel.textContent =
            state.mode === "study" ? "Study Sprint" : "Break Time";
        }

        function updateControls() {
          if (!pomodoroStartBtn || !pomodoroPauseBtn) return;
          if (state.running) {
            pomodoroStartBtn.disabled = true;
            pomodoroPauseBtn.disabled = false;
            pomodoroPauseBtn.textContent = "Pause";
          } else {
            pomodoroStartBtn.disabled = false;
            const showResume =
              state.startedOnce &&
              state.remainingSeconds < state.totalSeconds &&
              state.remainingSeconds > 0;
            pomodoroStartBtn.textContent = showResume ? "Resume" : "Start";
            pomodoroPauseBtn.disabled =
              state.remainingSeconds === state.totalSeconds ||
              state.remainingSeconds === 0;
            pomodoroPauseBtn.textContent = "Pause";
          }
        }

        function render() {
          const ratio =
            state.totalSeconds > 0
              ? 1 - state.remainingSeconds / state.totalSeconds
              : 0;
          setProgress(ratio);
          updateTimeDisplay();
          updatePhaseHint();
          updateDurationLabels();
          updateControls();
          updateModeSelector();
        }

        function startTicker() {
          if (state.timerId) return;
          state.lastTickTime = Date.now(); // Initialize timestamp
          state.timerId = window.setInterval(() => {
            if (!state.running) return;

            // Calculate actual elapsed time for accurate background handling
            const now = Date.now();
            const elapsed = Math.floor((now - state.lastTickTime) / 1000);
            state.lastTickTime = now;

            if (state.remainingSeconds > 0) {
              state.remainingSeconds = Math.max(
                0,
                state.remainingSeconds - elapsed
              );
              maybePlayPreAlert();
              render();
            }
            if (state.remainingSeconds <= 0) {
              // Stop the timer instead of auto-transitioning
              pausePomodoro();
              showSessionCompleteNotification();
            }
          }, 1000);
        }

        function stopTicker() {
          if (!state.timerId) return;
          window.clearInterval(state.timerId);
          state.timerId = null;
        }

        function startPomodoro() {
          if (state.running) return;
          if (
            !state.panelOpen &&
            window.matchMedia("(min-width: 1024px)").matches
          ) {
            openPanel();
          }
          state.running = true;
          state.startedOnce = true;
          updateControls();
          maybePlayPreAlert();
          startTicker();
        }

        function pausePomodoro() {
          if (!state.running) return;
          state.running = false;
          stopTicker();
          state.preAlertPlayed = false;
          resetPreAlertAudio();
          updateControls();
        }

        function resetPomodoro() {
          state.running = false;
          stopTicker();
          state.startedOnce = false;
          state.preAlertPlayed = false;
          resetPreAlertAudio();
          state.mode = state.startMode;
          const resetMinutes =
            state.mode === "break" ? state.breakMinutes : state.studyMinutes;
          state.totalSeconds = Math.max(1, resetMinutes * 60);
          state.remainingSeconds = state.totalSeconds;
          applyPalette();
          render();
        }

        function transitionMode() {
          stopTicker();
          if (state.mode === "study") {
            state.mode = "break";
            state.totalSeconds = Math.max(1, state.breakMinutes * 60);
            state.remainingSeconds = state.totalSeconds;
          } else {
            state.mode = "study";
            state.totalSeconds = Math.max(1, state.studyMinutes * 60);
            state.remainingSeconds = state.totalSeconds;
          }
          state.preAlertPlayed = false;
          applyPalette();
          pomodoroPanel.classList.add("mode-transition");
          window.setTimeout(() => {
            pomodoroPanel.classList.remove("mode-transition");
          }, 620);
          render();
          // Don't auto-start - let user manually start the next session
        }

        function showSessionCompleteNotification() {
          const sessionName =
            state.mode === "study" ? "Study session" : "Break time";

          // Play completion alert
          const audio = ensureTimerAlertAudio();
          if (audio) {
            try {
              audio.currentTime = 0;
              const playPromise = audio.play();
              if (playPromise?.catch) {
                playPromise.catch(() => {});
              }
            } catch (error) {
              console.warn("Failed to play completion alert", error);
            }
          }

          // Show browser notification if permission granted
          if (
            "Notification" in window &&
            Notification.permission === "granted"
          ) {
            try {
              new Notification("Pomodoro Timer", {
                body: `${sessionName} complete! Time for a ${
                  state.mode === "study" ? "break" : "study session"
                }.`,
                icon: "images/kwikmusiclogo.png",
                badge: "images/kwikmusiclogo.png",
                tag: "pomodoro-complete",
              });
            } catch (error) {
              console.warn("Failed to show notification", error);
            }
          }

          // Transition to next mode but don't start it
          transitionMode();
        }

        function setStudyMinutes(value) {
          const clamped = clampValue(value, STUDY_MIN, STUDY_MAX);
          state.studyMinutes = clamped;
          if (state.mode === "study") {
            const ratio =
              state.totalSeconds > 0
                ? state.remainingSeconds / state.totalSeconds
                : 1;
            state.totalSeconds = clamped * 60;
            state.remainingSeconds = state.running
              ? Math.max(1, Math.round(state.totalSeconds * ratio))
              : state.totalSeconds;
            state.preAlertPlayed = false;
            if (!state.running) {
              resetPreAlertAudio();
            }
          } else if (!state.running && state.startMode === "study") {
            state.mode = "study";
            state.totalSeconds = clamped * 60;
            state.remainingSeconds = state.totalSeconds;
            state.preAlertPlayed = false;
            resetPreAlertAudio();
          }
          updatePhaseHint();
          render();
        }

        function setBreakMinutes(value) {
          const clamped = clampValue(value, BREAK_MIN, BREAK_MAX);
          state.breakMinutes = clamped;
          if (state.mode === "break") {
            const ratio =
              state.totalSeconds > 0
                ? state.remainingSeconds / state.totalSeconds
                : 1;
            state.totalSeconds = clamped * 60;
            state.remainingSeconds = state.running
              ? Math.max(1, Math.round(state.totalSeconds * ratio))
              : state.totalSeconds;
            state.preAlertPlayed = false;
            if (!state.running) {
              resetPreAlertAudio();
            }
          } else if (!state.running && state.startMode === "break") {
            state.mode = "break";
            state.totalSeconds = clamped * 60;
            state.remainingSeconds = state.totalSeconds;
            state.preAlertPlayed = false;
            resetPreAlertAudio();
          }
          updatePhaseHint();
          render();
        }

        function setStartModePreference(mode) {
          if (state.running) return;
          const normalized = mode === "break" ? "break" : "study";
          if (state.startMode === normalized && state.mode === normalized) {
            return;
          }
          state.startMode = normalized;
          state.mode = normalized;
          const minutes =
            normalized === "break" ? state.breakMinutes : state.studyMinutes;
          state.totalSeconds = Math.max(1, minutes * 60);
          state.remainingSeconds = state.totalSeconds;
          state.startedOnce = false;
          state.preAlertPlayed = false;
          resetPreAlertAudio();
          applyPalette();
          render();
          persistSettings();
        }

        function openPanel() {
          if (state.panelOpen) return;
          state.panelOpen = true;
          pomodoroPanel.classList.add("active");
          pomodoroPanel.setAttribute("aria-hidden", "false");
          pomodoroBtn.classList.add("active");
          pomodoroBtn.setAttribute("aria-expanded", "true");
          applyPalette();
          render();
        }

        function closePanel() {
          if (!state.panelOpen) return;
          state.panelOpen = false;
          pomodoroPanel.classList.remove("active");
          pomodoroPanel.setAttribute("aria-hidden", "true");
          pomodoroBtn.classList.remove("active");
          pomodoroBtn.setAttribute("aria-expanded", "false");
        }

        function togglePanel() {
          if (state.panelOpen) {
            closePanel();
          } else {
            openPanel();
          }
        }

        function handleStudyInput(event, commit) {
          const newValue = parseInt(event.target.value, 10);
          if (Number.isNaN(newValue)) return;
          setStudyMinutes(newValue);
          if (commit) persistSettings();
        }

        function handleBreakInput(event, commit) {
          const newValue = parseInt(event.target.value, 10);
          if (Number.isNaN(newValue)) return;
          setBreakMinutes(newValue);
          if (commit) persistSettings();
        }

        pomodoroBtn.setAttribute("aria-expanded", "false");
        pomodoroBtn.addEventListener("click", togglePanel);
        
        // Close button for mobile
        const pomodoroCloseBtn = document.getElementById("pomodoroCloseBtn");
        if (pomodoroCloseBtn) {
          pomodoroCloseBtn.addEventListener("click", closePanel);
        }
        
        if (pomodoroStartBtn) {
          pomodoroStartBtn.addEventListener("click", startPomodoro);
        }
        if (pomodoroPauseBtn) {
          pomodoroPauseBtn.addEventListener("click", pausePomodoro);
        }
        if (pomodoroResetBtn) {
          pomodoroResetBtn.addEventListener("click", resetPomodoro);
        }
        if (studyDurationInput) {
          studyDurationInput.addEventListener("input", (event) =>
            handleStudyInput(event, false)
          );
          studyDurationInput.addEventListener("change", (event) =>
            handleStudyInput(event, true)
          );
        }
        if (breakDurationInput) {
          breakDurationInput.addEventListener("input", (event) =>
            handleBreakInput(event, false)
          );
          breakDurationInput.addEventListener("change", (event) =>
            handleBreakInput(event, true)
          );
        }

        if (modeOptions && modeOptions.length) {
          modeOptions.forEach((button) => {
            button.addEventListener("click", () => {
              setStartModePreference(button.dataset.mode);
            });
          });
        }

        // Handle page visibility changes for accurate background timing
        document.addEventListener("visibilitychange", () => {
          if (state.running) {
            if (document.visibilityState === "visible") {
              // Reset timestamp when coming back to foreground
              state.lastTickTime = Date.now();
            }
          }
        });

        // Request notification permission when panel is first opened
        pomodoroBtn.addEventListener(
          "click",
          () => {
            if (
              "Notification" in window &&
              Notification.permission === "default"
            ) {
              Notification.requestPermission();
            }
          },
          { once: true }
        );

        applyPalette();
        render();
      })();

      // Load YouTube IFrame API
      function loadYouTubeAPI() {
        const tag = document.createElement("script");
        tag.src = "https://www.youtube.com/iframe_api";
        const firstScriptTag = document.getElementsByTagName("script")[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
      }

      // Initialize YouTube Player
      function onYouTubeIframeAPIReady() {
        youtubePlayer = new YT.Player("youtube-player", {
          height: "1",
          width: "1",
          videoId: "",
          playerVars: {
            autoplay: 1, // Enable autoplay for PWA
            controls: 0,
            disablekb: 1,
            enablejsapi: 1,
            fs: 0,
            iv_load_policy: 3,
            modestbranding: 1,
            playsinline: 1,
            rel: 0,
            origin: window.location.origin, // Important for PWA
          },
          events: {
            onReady: onPlayerReady,
            onStateChange: onPlayerStateChange,
          },
        });
      }

      function onPlayerReady(event) {
        isPlayerReady = true;
        console.log("YouTube player ready");

        // Set volume to 100 immediately (critical for PWA audio)
        try {
          event.target.setVolume(100);
          event.target.unMute();
        } catch (err) {
          console.warn("Failed to set initial volume:", err);
        }

        // Ensure iframe has proper permissions for PWA standalone mode
        try {
          const iframe = event?.target?.getIframe?.();
          if (iframe) {
            // Critical: Add all necessary permissions for PWA audio playback
            iframe.setAttribute(
              "allow",
              "autoplay *; fullscreen *; encrypted-media *; accelerometer; gyroscope; picture-in-picture; clipboard-write"
            );
            iframe.setAttribute("referrerpolicy", "origin");
            // For PWA: ensure iframe is in the document flow properly
            iframe.style.position = "absolute";
            iframe.style.pointerEvents = "none";
          }
        } catch (err) {
          console.warn("Failed to set iframe permissions:", err);
        }

        // PWA Audio Context unlock: Create and interact with audio context on user gesture
        unlockAudioContext();
      }

      // Unlock audio context for PWA (fixes iOS/Android standalone audio issues)
      let audioContextUnlocked = false;
      function unlockAudioContext() {
        if (audioContextUnlocked) return;

        try {
          // Create a silent audio context to unlock audio on mobile PWA
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          if (AudioContext) {
            const audioCtx = new AudioContext();
            const silentAudio = audioCtx.createBufferSource();
            silentAudio.buffer = audioCtx.createBuffer(1, 1, 22050);
            silentAudio.connect(audioCtx.destination);
            silentAudio.start(0);
            audioCtx
              .resume()
              .then(() => {
                audioContextUnlocked = true;
                console.log(" Audio context unlocked for PWA");
              })
              .catch((err) => {
                console.warn("Audio context unlock failed:", err);
              });
          }
        } catch (err) {
          console.warn("AudioContext unlock error:", err);
        }
      }

      // Media Session API integration for background controls/metadata
      const mediaSessionSupported = "mediaSession" in navigator;
      function setupMediaSessionHandlers() {
        if (!mediaSessionSupported) return;
        try {
          // Base play/pause/stop handlers
          navigator.mediaSession.setActionHandler("play", () => {
            try {
              lastPauseByUser = false;
              youtubePlayer?.playVideo?.();
            } catch {}
          });
          navigator.mediaSession.setActionHandler("pause", () => {
            try {
              lastPauseByUser = true;
              youtubePlayer?.pauseVideo?.();
            } catch {}
          });
          navigator.mediaSession.setActionHandler("stop", () => {
            try {
              lastPauseByUser = true;
              youtubePlayer?.pauseVideo?.();
            } catch {}
          });
          // We set prev/next dynamically based on queue length so Android notification shows buttons reliably
          refreshPrevNextHandlers();
          // Remove seek handlers so system prefers prev/next buttons over +/- 10s on Android notification
          ["seekbackward", "seekforward", "seekto"].forEach((act) => {
            try {
              navigator.mediaSession.setActionHandler(act, null);
            } catch {}
          });
        } catch (e) {
          console.warn("MediaSession handlers failed", e);
        }
      }
      function refreshPrevNextHandlers() {
        if (!mediaSessionSupported) return;
        const multi = currentSearchResults && currentSearchResults.length > 1;
        try {
          if (multi) {
            navigator.mediaSession.setActionHandler("previoustrack", () => {
              try {
                lastPauseByUser = false;
                playPreviousTrack();
              } catch {}
            });
            navigator.mediaSession.setActionHandler("nexttrack", () => {
              try {
                lastPauseByUser = false;
                playNextTrack();
              } catch {}
            });
          } else {
            // disable to hide on some UIs (gracefully ignore errors)
            try {
              navigator.mediaSession.setActionHandler("previoustrack", null);
            } catch {}
            try {
              navigator.mediaSession.setActionHandler("nexttrack", null);
            } catch {}
          }
        } catch (e) {
          console.warn("refreshPrevNextHandlers failed", e);
        }
      }
      function updateMediaSessionMetadata(track) {
        if (!mediaSessionSupported || !track) return;
        try {
          const artwork = track.thumbnail
            ? [
                { src: track.thumbnail, sizes: "96x96", type: "image/jpeg" },
                { src: track.thumbnail, sizes: "128x128", type: "image/jpeg" },
                { src: track.thumbnail, sizes: "192x192", type: "image/jpeg" },
                { src: track.thumbnail, sizes: "256x256", type: "image/jpeg" },
                { src: track.thumbnail, sizes: "320x320", type: "image/jpeg" },
                { src: track.thumbnail, sizes: "512x512", type: "image/jpeg" },
              ]
            : undefined;
          navigator.mediaSession.metadata = new MediaMetadata({
            title: track.title || "",
            artist: track.channel || "",
            album: "KwikMusic",
            artwork,
          });
          refreshPrevNextHandlers();
        } catch (e) {
          console.warn("MediaSession metadata failed", e);
        }
      }
      function updateMediaSessionPlaybackState(state) {
        if (!mediaSessionSupported) return;
        try {
          navigator.mediaSession.playbackState = state; // 'none' | 'paused' | 'playing'
        } catch {}
      }
      function updateMediaSessionPosition() {
        if (!mediaSessionSupported) return;
        try {
          const pos = youtubePlayer?.getCurrentTime?.() || 0;
          const dur = youtubePlayer?.getDuration?.() || 0;
          if (
            typeof navigator.mediaSession.setPositionState === "function" &&
            dur > 0
          ) {
            navigator.mediaSession.setPositionState({
              duration: dur,
              position: pos,
              playbackRate: 1.0,
            });
          }
        } catch {}
      }

      // Rain helpers
      function initRainAudio() {
        if (!rainAudio) {
          try {
            rainAudio = new Audio("rain.mp3");
            rainAudio.loop = true;
            try {
              const savedVol = parseFloat(
                localStorage.getItem("kwikmusic_rain_vol")
              );
              if (!Number.isNaN(savedVol))
                rainVolume = Math.max(0, Math.min(1, savedVol));
            } catch {}
            rainAudio.volume = rainVolume;
          } catch (e) {
            console.warn("Rain audio init failed", e);
          }
        }
      }
      function setRain(on) {
        initRainAudio();
        if (!rainAudio) return;
        isRainOn = !!on;
        if (isRainOn) {
          rainAudio
            .play()
            .catch((e) =>
              console.log("Rain play blocked until user gesture", e)
            );
        } else {
          try {
            rainAudio.pause();
          } catch {}
        }
        if (rainToggleBtn) {
          rainToggleBtn.classList.toggle("active", isRainOn);
          rainToggleBtn.setAttribute("aria-pressed", String(isRainOn));
          rainToggleBtn.title = isRainOn ? "Rain: On" : "Rain: Off";
        }
      }
      function setRainVolume(vol01) {
        rainVolume = Math.max(0, Math.min(1, vol01));
        if (rainAudio) rainAudio.volume = rainVolume;
        try {
          localStorage.setItem("kwikmusic_rain_vol", String(rainVolume));
        } catch {}
      }

      function onPlayerStateChange(event) {
        if (event.data == YT.PlayerState.PLAYING) {
          updatePlayPauseButtons("");
          startYouTubeProgressTracking();
          startProgressRing();
          updateMediaSessionPlaybackState("playing");

          // PWA Fix: Ensure volume is set when playback starts
          try {
            event.target.unMute();
            event.target.setVolume(100);
          } catch (err) {
            console.warn("Failed to ensure volume:", err);
          }

          try {
            miniPlayer.classList.add("playing");
            fullPlayer.classList.add("playing");
          } catch {}
          bgResumeAttempted = false; // reset any pending resume attempts
          // playing means no active pause intent
          lastPauseByUser = false;
          // stop any hidden auto-resume loop
          if (bgResumeTimer) {
            clearInterval(bgResumeTimer);
            bgResumeTimer = null;
            bgResumeTries = 0;
          }
        } else if (event.data == YT.PlayerState.PAUSED) {
          updatePlayPauseButtons("");
          stopYouTubeProgressTracking();
          stopProgressRing();
          updateMediaSessionPlaybackState("paused");
          try {
            miniPlayer.classList.remove("playing");
            fullPlayer.classList.remove("playing");
          } catch {}
          // If the page just went to background and we were playing, attempt a gentle resume (Android-friendly)
          if (
            document.visibilityState === "hidden" &&
            wasPlayingOnHide &&
            !bgResumeAttempted &&
            !lastPauseByUser
          ) {
            bgResumeAttempted = true;
            // Start a short retry loop to overcome timing issues on Android
            if (bgResumeTimer) clearInterval(bgResumeTimer);
            bgResumeTries = 0;
            bgResumeTimer = setInterval(() => {
              try {
                const stillHidden = document.visibilityState === "hidden";
                if (stillHidden && !lastPauseByUser && bgResumeTries < 8) {
                  youtubePlayer?.playVideo?.();
                  bgResumeTries++;
                } else {
                  clearInterval(bgResumeTimer);
                  bgResumeTimer = null;
                }
              } catch {
                clearInterval(bgResumeTimer);
                bgResumeTimer = null;
              }
            }, 700);
          }
        } else if (event.data == YT.PlayerState.ENDED) {
          updatePlayPauseButtons("");
          stopYouTubeProgressTracking();
          updateMediaSessionPlaybackState("none");
          if (repeatMode === "one") {
            // restart same track
            youtubePlayer.seekTo(0, true);
            youtubePlayer.playVideo();
          } else {
            const advanced = playNextTrack();
            if (
              !advanced &&
              repeatMode === "all" &&
              currentSearchResults.length > 0
            ) {
              currentYouTubeIndex = 0;
              playYouTubeMusic(currentSearchResults[currentYouTubeIndex]);
            }
          }
        }
      }

      // Search YouTube Music
      async function searchYouTube(query) {
        if (!query.trim()) return;

        searchResults.innerHTML = '<div class="loading">Searching...</div>';
        searchSuggestions.style.display = "none";

        try {
          let apiKey = getYouTubeApiKey();
          const response = await fetch(
            `https://www.googleapis.com/youtube/v3/search?part=snippet&maxResults=20&q=${encodeURIComponent(
              query + " music"
            )}&type=video&videoCategoryId=10&key=${apiKey}`
          );

          if (!response.ok) {
            // If 403, try switching to next API key
            if (response.status === 403) {
              console.warn(" YouTube API quota exceeded, switching key...");
              apiKey = switchToNextApiKey();
              const retryResponse = await fetch(
                `https://www.googleapis.com/youtube/v3/search?part=snippet&maxResults=20&q=${encodeURIComponent(
                  query + " music"
                )}&type=video&videoCategoryId=10&key=${apiKey}`
              );
              if (!retryResponse.ok) {
                throw new Error(`HTTP error! status: ${retryResponse.status}`);
              }
              const retryData = await retryResponse.json();
              return await processSearchResults(retryData, apiKey, query);
            }
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();
          return await processSearchResults(data, apiKey, query);
        } catch (error) {
          console.error("Search error:", error);
          searchResults.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #ff6b6b;">
              Error searching YouTube. Please check your connection and try again.
            </div>
          `;
        }
      }

      // Helper function to process search results
      async function processSearchResults(data, apiKey, query) {
        if (data.items && data.items.length > 0) {
          const videoIds = data.items.map((item) => item.id.videoId).join(",");

          const detailsResponse = await fetch(
            `https://www.googleapis.com/youtube/v3/videos?part=contentDetails,snippet&id=${videoIds}&key=${apiKey}`
          );

          const detailsData = await detailsResponse.json();

          const results = detailsData.items.map((item, index) => ({
            id: item.id,
            title: item.snippet.title,
            channel: item.snippet.channelTitle,
            thumbnail:
              item.snippet.thumbnails.medium?.url ||
              item.snippet.thumbnails.default?.url,
            duration: formatYouTubeDuration(item.contentDetails.duration),
          }));

          displaySearchResults(results);
        } else {
          searchResults.innerHTML = `
            <div style="text-align: center; padding: 40px; color: rgba(255, 255, 255, 0.7);">
              No results found for "${query}"
            </div>
          `;
        }
      }

      // Display search results
      function displaySearchResults(results) {
        searchResults.innerHTML = "";
        currentSearchResults = results;
        searchSuggestions.style.display = results.length ? "none" : "block";

        results.forEach((result, index) => {
          const resultItem = document.createElement("div");
          resultItem.className = "search-result-item";

          resultItem.innerHTML = `
            <div class="result-thumbnail">
              <img src="${result.thumbnail}" alt="${result.title}" onerror="this.src='images/bg.png'">
            </div>
            <div class="result-info">
              <div class="result-title">${result.title}</div>
              <div class="result-channel">${result.channel}</div>
            </div>
            <div class="result-duration">${result.duration}</div>
            <div class="result-actions">
        <button class="icon-btn heart" title="Favorite" data-id="${result.id}"><svg class="icon"><use href="#ic-heart"/></svg></button>
        <button class="icon-btn" title="Add to playlist" data-id="${result.id}"><svg class="icon"><use href="#ic-plus"/></svg></button>
            </div>
          `;

          resultItem.addEventListener("click", () => {
            unlockAudioContext(); // Unlock audio on user interaction
            currentYouTubeIndex = index;
            playYouTubeMusic(result);
          });

          // Action buttons
          const [favBtn, addBtn] = resultItem.querySelectorAll(
            ".result-actions .icon-btn"
          );
          favBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            toggleFavorite(result);
            updateSearchResultFavoriteUI(favBtn, result.id);
          });
          addBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            openPlaylistPicker(result);
          });

          searchResults.appendChild(resultItem);
        });

        // Set initial heart states
        document
          .querySelectorAll(".result-actions .icon-btn.heart")
          .forEach((btn) => {
            const id = btn.getAttribute("data-id");
            if (isFavoriteId(id)) {
              btn.classList.add("active");
              btn.innerHTML =
                '<svg class="icon"><use href="#ic-heart-fill"/></svg>';
            }
          });
      }

      // Suggestions rendering from favorites + playlists (unique by id)
      function renderSuggestions() {
        if (!searchSuggestions || !suggestionsList) return;
        const favs = loadFavorites(); // newest first
        const pls = loadPlaylists();
        // Build a combined, newest-first list:
        const combined = [];
        combined.push(...favs);
        pls.forEach((p) => combined.push(...(p.tracks || []))); // tracks are unshifted when added (newest first)
        // Deduplicate by id preserving first occurrence
        const seen = new Set();
        const unique = [];
        for (const t of combined) {
          if (t && t.id && !seen.has(t.id)) {
            seen.add(t.id);
            unique.push(t);
          }
        }
        // Only keep top 5 recent items
        const recent = unique.slice(0, 5);

        suggestionsList.innerHTML = "";
        if (recent.length === 0) {
          searchSuggestions.style.display = "none";
          return;
        }
        searchSuggestions.style.display = "block";

        recent.forEach((track, index) => {
          const item = document.createElement("div");
          item.className = "suggestion-item";
          item.innerHTML = `
            <div class="result-thumbnail"><img src="${track.thumbnail}" alt="${
            track.title
          }" onerror="this.src='images/bg.png'"></div>
            <div class="result-info">
              <div class="result-title">${track.title}</div>
              <div class="result-channel">${track.channel}</div>
            </div>
            <div class="result-duration">${track.duration || ""}</div>
          `;
          item.addEventListener("click", () => {
            // Play from recent list to preserve its order
            playFromList(recent, index);
          });
          suggestionsList.appendChild(item);
        });
      }

      // Play YouTube Music
      function playYouTubeMusic(result) {
        if (!isPlayerReady) {
          console.log("YouTube player not ready yet");
          return;
        }

        // Stop any current recording playback
        if (window.currentRecordingAudio) {
          window.currentRecordingAudio.pause();
          window.currentRecordingAudio = null;
          window.currentRecording = null;
          if (window.currentAudioUrl) {
            URL.revokeObjectURL(window.currentAudioUrl);
            window.currentAudioUrl = null;
          }
          // Remove playing class from progress bar
          const progressBar = document.getElementById("progressBar");
          if (progressBar) progressBar.classList.remove("playing");

          // Clear recording queue when YouTube starts
          isPlayingRecordingQueue = false;
          currentRecordingQueue = [];
          currentRecordingIndex = -1;
        }

        currentYouTubeTrack = result;

        // Update UI
        updatePlayerUI(result);
        showMiniPlayer();

        // Unlock audio context on first user interaction (critical for PWA)
        unlockAudioContext();

        // Load and play video with PWA-friendly approach
        try {
          youtubePlayer.loadVideoById(result.id);

          // For PWA: Add retry logic to ensure playback starts
          const attemptPlay = () => {
            try {
              lastPauseByUser = false;
              youtubePlayer.playVideo();

              // Verify playback started after a short delay
              setTimeout(() => {
                try {
                  const state = youtubePlayer.getPlayerState();
                  if (
                    state !== YT.PlayerState.PLAYING &&
                    state !== YT.PlayerState.BUFFERING
                  ) {
                    console.log("Retrying playback for PWA...");
                    youtubePlayer.playVideo();
                  }
                } catch (err) {
                  console.warn("Playback verification error:", err);
                }
              }, 500);
            } catch (err) {
              console.warn("Play attempt failed:", err);
            }
          };

          // Attempt play immediately and after load
          attemptPlay();
          setTimeout(attemptPlay, 100);
        } catch (err) {
          console.error("playYouTubeMusic error:", err);
        }

        updateMediaSessionMetadata(result);
        updateMediaSessionPlaybackState("playing");
        refreshPrevNextHandlers();
      }

      // Update Player UI
      function updatePlayerUI(result) {
        // Mini player
        document.getElementById("miniArtwork").src = result.thumbnail;
        document.getElementById("miniTitle").textContent = result.title;
        document.getElementById("miniArtist").textContent = result.channel;

        // Full player
        document.getElementById("fullArtwork").src = result.thumbnail;
        document.getElementById("fullTitle").textContent = result.title;
        document.getElementById("fullArtist").textContent = result.channel;
        // Dynamic accent extraction (quick average via canvas)
        try {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.referrerPolicy = "no-referrer";
          img.onload = () => {
            try {
              const canvas = document.createElement("canvas");
              const ctx = canvas.getContext("2d");
              const size = 32;
              canvas.width = canvas.height = size;
              ctx.drawImage(img, 0, 0, size, size);
              const data = ctx.getImageData(0, 0, size, size).data;
              const samples = [];
              for (let i = 0; i < data.length; i += 16) {
                const r = data[i],
                  g = data[i + 1],
                  b = data[i + 2];
                const maxc = Math.max(r, g, b),
                  minc = Math.min(r, g, b);
                if (maxc > 238 || minc < 18) continue; // ignore extremes
                samples.push([r, g, b]);
              }
              if (samples.length > 12) {
                // Simple 3-cluster color grouping using iterative refinement
                let centroids = [
                  samples[0],
                  samples[Math.floor(samples.length / 3)],
                  samples[Math.floor((samples.length * 2) / 3)],
                ];
                for (let iter = 0; iter < 6; iter++) {
                  const buckets = [[], [], []];
                  for (const px of samples) {
                    let bi = 0,
                      bd = 1e9;
                    for (let c = 0; c < 3; c++) {
                      const ct = centroids[c];
                      const d =
                        (px[0] - ct[0]) ** 2 +
                        (px[1] - ct[1]) ** 2 +
                        (px[2] - ct[2]) ** 2;
                      if (d < bd) {
                        bd = d;
                        bi = c;
                      }
                    }
                    buckets[bi].push(px);
                  }
                  for (let c = 0; c < 3; c++) {
                    if (buckets[c].length) {
                      let r = 0,
                        g = 0,
                        b = 0;
                      for (const p of buckets[c]) {
                        r += p[0];
                        g += p[1];
                        b += p[2];
                      }
                      const n = buckets[c].length;
                      centroids[c] = [
                        Math.round(r / n),
                        Math.round(g / n),
                        Math.round(b / n),
                      ];
                    }
                  }
                }
                // Rank by perceived luminance to order gradients nicely
                centroids = centroids.sort(
                  (a, b) =>
                    0.299 * a[0] +
                    0.587 * a[1] +
                    0.114 * a[2] -
                    (0.299 * b[0] + 0.587 * b[1] + 0.114 * b[2])
                );
                const [c1, c2, c3] = centroids;
                const col1 = `rgb(${c1[0]},${c1[1]},${c1[2]})`;
                const col2 = `rgb(${c2[0]},${c2[1]},${c2[2]})`;
                const col3 = `rgb(${c3[0]},${c3[1]},${c3[2]})`;
                const glow = `rgba(${c3[0]},${c3[1]},${c3[2]},0.55)`;
                const root = document.documentElement.style;
                root.setProperty("--km-accent", col2);
                root.setProperty("--km-accent-alt", col3);
                root.setProperty("--km-full-grad-1", col1);
                root.setProperty("--km-full-grad-2", col2);
                root.setProperty("--km-full-grad-3", col3);
                root.setProperty("--km-full-bg-glow", glow);
                const fp = document.getElementById("fullPlayer");
                if (fp) {
                  fp.style.background = `linear-gradient(135deg, ${col1} 0%, ${col2} 55%, ${col3} 100%)`;
                  fp.style.backgroundAttachment = "fixed";
                }
              }
            } catch {}
          };
          img.src = result.thumbnail;
        } catch {}
        // Reset progress ring on new track
        const ring = document.getElementById("miniProgressCircle");
        if (ring) ring.style.strokeDashoffset = 157;
      }

      // Progress Ring logic
      let progressRingInterval = null;
      function startProgressRing() {
        const circle = document.getElementById("miniProgressCircle");
        if (
          !circle ||
          !youtubePlayer ||
          typeof youtubePlayer.getDuration !== "function"
        )
          return;
        const total = youtubePlayer.getDuration();
        if (!total) return;
        const circumference = 157; // 2r where r=25
        function tick() {
          if (!circle) return;
          const cur = youtubePlayer.getCurrentTime
            ? youtubePlayer.getCurrentTime()
            : 0;
          const ratio = Math.min(1, cur / (total || 1));
          circle.style.strokeDashoffset = (
            circumference -
            circumference * ratio
          ).toFixed(2);
          if (ratio >= 1) {
            stopProgressRing();
          }
        }
        stopProgressRing();
        progressRingInterval = setInterval(tick, 500);
      }
      function stopProgressRing() {
        if (progressRingInterval) {
          clearInterval(progressRingInterval);
          progressRingInterval = null;
        }
      }

      // Show/Hide Mini Player
      function showMiniPlayer() {
        miniPlayer.style.display = "block";
        try {
          document.querySelector(".main-content")?.classList.add("with-mini");
        } catch {}
      }

      function hideMiniPlayer() {
        miniPlayer.style.display = "none";
        try {
          document
            .querySelector(".main-content")
            ?.classList.remove("with-mini");
        } catch {}
      }

      // Show/Hide Full Player
      function showFullPlayer() {
        fullPlayer.classList.add("active");
      }

      function hideFullPlayer() {
        fullPlayer.classList.remove("active");
      }

      // Full player gestures: swipe down to minimize, left/right to prev/next
      (function enableFullPlayerGestures() {
        let startX = 0,
          startY = 0,
          curX = 0,
          curY = 0,
          dragging = false,
          axis = null; // 'x' or 'y'
        const closeThreshold = 80;
        const swipeThreshold = 80;
        const hintL = document.getElementById("swipeHintLeft");
        const hintR = document.getElementById("swipeHintRight");

        function resetHints() {
          if (hintL) {
            hintL.style.opacity = "0";
            const c = hintL.querySelector(".hint-content");
            if (c) c.style.transform = "translateX(0)";
          }
          if (hintR) {
            hintR.style.opacity = "0";
            const c = hintR.querySelector(".hint-content");
            if (c) c.style.transform = "translateX(0)";
          }
        }

        function onStart(e) {
          // Avoid starting gesture on sliders/controls
          const target = e.target;
          if (
            target.closest &&
            (target.closest(".progress-bar") ||
              target.closest(".volume-slider") ||
              target.closest(".full-controls"))
          )
            return;
          const t = e.touches ? e.touches[0] : e;
          dragging = true;
          axis = null;
          startX = curX = t.clientX;
          startY = curY = t.clientY;
          fullPlayer.style.transition = "none";
          resetHints();
        }
        function onMove(e) {
          if (!dragging) return;
          const t = e.touches ? e.touches[0] : e;
          curX = t.clientX;
          curY = t.clientY;
          const dx = curX - startX;
          const dy = curY - startY;
          if (!axis) {
            if (Math.abs(dx) > 12 || Math.abs(dy) > 12) {
              axis = Math.abs(dx) > Math.abs(dy) ? "x" : "y";
            } else {
              return;
            }
          }
          if (axis === "y") {
            const ty = Math.max(0, dy);
            fullPlayer.style.transform = `translateY(${ty}px)`;
            // hide hints during vertical drag
            resetHints();
          } else if (axis === "x") {
            // Small visual feedback for swipe
            const tx = Math.max(-150, Math.min(150, dx));
            fullPlayer.style.transform = `translateX(${tx}px)`;

            // Show appropriate hint based on direction and intensity
            const intensity = Math.min(1, Math.abs(dx) / 120);
            if (dx > 0) {
              if (hintL) {
                hintL.style.opacity = String(intensity);
                const c = hintL.querySelector(".hint-content");
                if (c)
                  c.style.transform = `translateX(${Math.min(16, dx * 0.1)}px)`;
              }
              if (hintR) hintR.style.opacity = "0";
            } else if (dx < 0) {
              if (hintR) {
                hintR.style.opacity = String(intensity);
                const c = hintR.querySelector(".hint-content");
                if (c)
                  c.style.transform = `translateX(${Math.max(
                    -16,
                    dx * 0.1
                  )}px)`;
              }
              if (hintL) hintL.style.opacity = "0";
            } else {
              resetHints();
            }
          }
        }
        function onEnd() {
          if (!dragging) return;
          const dx = curX - startX;
          const dy = curY - startY;
          fullPlayer.style.transition = "transform 0.25s ease";
          if (axis === "y" && dy > closeThreshold) {
            fullPlayer.classList.remove("active");
            requestAnimationFrame(() => (fullPlayer.style.transform = ""));
          } else if (axis === "x") {
            if (dx < -swipeThreshold) {
              // next
              try {
                playNextTrack();
              } catch {}
            } else if (dx > swipeThreshold) {
              // prev
              try {
                playPreviousTrack();
              } catch {}
            }
            fullPlayer.style.transform = "";
          } else {
            fullPlayer.style.transform = "";
          }
          // fade hints quickly
          resetHints();
          dragging = false;
          axis = null;
        }

        // Attach on full player area
        fullPlayer.addEventListener("touchstart", onStart, { passive: true });
        fullPlayer.addEventListener("touchmove", onMove, { passive: true });
        fullPlayer.addEventListener("touchend", onEnd);
        // Optional mouse support (start only on top area to avoid conflicts)
        fullPlayer.addEventListener("mousedown", (e) => {
          const rect = fullPlayer.getBoundingClientRect();
          if (e.clientY - rect.top < rect.height * 0.5) onStart(e);
        });
        document.addEventListener("mousemove", onMove);
        document.addEventListener("mouseup", onEnd);
      })();

      // Mini-player gestures: swipe up to expand, left/right to next/prev, swipe down to dismiss & stop
      (function enableMiniPlayerGestures() {
        if (!miniPlayer) return;
        let sx = 0,
          sy = 0,
          cx = 0,
          cy = 0,
          dragging = false,
          axis = null,
          lastMoveTime = 0,
          lastX = 0,
          lastY = 0,
          moved = false;
        const upThreshold = 60; // slightly higher to avoid accidental expands
        const swipeThreshold = 80; // align with full player threshold
        const downDismissThreshold = 60; // swipe down distance to dismiss mini-player

        function setTransform(x, y) {
          // preserve centering translateX(-50%) while applying deltas
          miniPlayer.style.transform = `translate(calc(-50% + ${x}px), ${y}px)`;
        }

        function start(e) {
          const target = e.target;
          if (target.closest && target.closest(".mini-controls")) return;
          const t = e.touches ? e.touches[0] : e;
          dragging = true;
          axis = null;
          sx = cx = t.clientX;
          sy = cy = t.clientY;
          lastX = sx;
          lastY = sy;
          lastMoveTime = performance.now();
          moved = false;
          miniPlayer.style.transition = "none";
        }
        function move(e) {
          if (!dragging) return;
          const t = e.touches ? e.touches[0] : e;
          cx = t.clientX;
          cy = t.clientY;
          const dx = cx - sx;
          const dy = cy - sy;
          if (!axis && (Math.abs(dx) > 8 || Math.abs(dy) > 8)) {
            axis = Math.abs(dy) > Math.abs(dx) ? "y" : "x";
          }
          if (axis === "y") {
            if (dy < 0) {
              const ty = Math.max(-90, dy); // upward (negative)
              setTransform(0, ty);
              moved = true;
            } else if (dy > 0) {
              const ty = Math.min(110, dy); // downward drag preview
              setTransform(0, ty);
              moved = true;
            }
          } else if (axis === "x") {
            const tx = Math.max(-110, Math.min(110, dx));
            setTransform(tx, 0);
            moved = true;
          }
          // prevent page scroll while swiping mini player
          if (e.cancelable) e.preventDefault();
          lastX = cx;
          lastY = cy;
          lastMoveTime = performance.now();
        }
        function end() {
          if (!dragging) return;
          const dx = cx - sx;
          const dy = cy - sy;
          miniPlayer.style.transition = "transform 0.2s ease";
          if (axis === "y") {
            if (dy < -upThreshold) {
              miniPlayer.style.transform = "translateX(-50%)";
              showFullPlayer();
            } else if (dy > downDismissThreshold) {
              // Dismiss mini-player & stop playback
              try {
                stopYouTubeProgressTracking();
                stopProgressRing?.();

                // Stop YouTube playback
                youtubePlayer?.pauseVideo?.();

                // Stop recording playback if active
                if (window.currentRecordingAudio) {
                  window.currentRecordingAudio.pause();
                  window.currentRecordingAudio.currentTime = 0;
                  if (window.currentAudioUrl) {
                    URL.revokeObjectURL(window.currentAudioUrl);
                  }
                  window.currentRecordingAudio = null;
                  window.currentRecording = null;
                  window.currentAudioUrl = null;

                  // Clear recording queue
                  isPlayingRecordingQueue = false;
                  currentRecordingQueue = [];
                  currentRecordingIndex = -1;

                  // Remove playing class from progress bar
                  const progressBar = document.getElementById("progressBar");
                  if (progressBar) progressBar.classList.remove("playing");
                }

                miniPlayer.classList.remove("playing");
                fullPlayer.classList.remove("playing");
                updateMediaSessionPlaybackState?.("none");
              } catch {}
              hideMiniPlayer();
              // reset transform for next time it's shown
              miniPlayer.style.transform = "translateX(-50%)";
              dragging = false;
              axis = null;
              return;
            } else {
              miniPlayer.style.transform = "translateX(-50%)";
            }
          } else if (axis === "x") {
            if (dx < -swipeThreshold) {
              try {
                playNextTrack();
              } catch {}
            } else if (dx > swipeThreshold) {
              try {
                playPreviousTrack();
              } catch {}
            }
            miniPlayer.style.transform = "translateX(-50%)";
          } else {
            miniPlayer.style.transform = "translateX(-50%)";
          }
          dragging = false;
          axis = null;
          // If user swiped, suppress the next click to avoid accidental expand
          if (moved) {
            const once = (ev) => {
              ev.stopPropagation();
              miniPlayer.removeEventListener("click", once, true);
            };
            miniPlayer.addEventListener("click", once, true);
          }
        }

        miniPlayer.addEventListener("touchstart", start, { passive: true });
        // need passive:false so we can preventDefault to stop page scroll
        miniPlayer.addEventListener("touchmove", move, { passive: false });
        miniPlayer.addEventListener("touchend", end);
        miniPlayer.addEventListener("mousedown", start);
        document.addEventListener("mousemove", move);
        document.addEventListener("mouseup", end);
      })();

      // Update Play/Pause Buttons
      function updatePlayPauseButtons(icon) {
        const isPause = icon.includes("");
        miniPlayPauseBtn.innerHTML = isPause
          ? '<svg class="icon"><use href="#ic-pause"/></svg>'
          : '<svg class="icon"><use href="#ic-play"/></svg>';
        playPauseBtn.innerHTML = isPause
          ? '<svg class="icon"><use href="#ic-pause"/></svg>'
          : '<svg class="icon"><use href="#ic-play"/></svg>';
      }

      // Progress Tracking
      function startYouTubeProgressTracking() {
        if (youTubeProgressInterval) clearInterval(youTubeProgressInterval);
        youTubeProgressInterval = setInterval(() => {
          if (youtubePlayer && youtubePlayer.getCurrentTime) {
            updateYouTubeProgress();
            updateMediaSessionPosition();
          }
        }, 500);
      }

      function stopYouTubeProgressTracking() {
        if (youTubeProgressInterval) {
          clearInterval(youTubeProgressInterval);
          youTubeProgressInterval = null;
        }
      }

      function updateYouTubeProgress() {
        // Don't update progress if a recording is currently playing
        if (
          window.currentRecordingAudio &&
          !window.currentRecordingAudio.paused
        ) {
          return;
        }

        try {
          const current = youtubePlayer.getCurrentTime();
          const duration = youtubePlayer.getDuration();

          if (duration > 0) {
            const percent = (current / duration) * 100;
            progressCurrent.style.width = percent + "%";
            progressHandle.style.left = percent + "%";
            // mini linear progress removed

            currentTime.textContent = formatTime(current);
            totalTime.textContent = formatTime(duration);
          }
        } catch (error) {
          console.log("Progress update error:", error);
        }
      }

      // Seeking
      function seekYouTube(percent) {
        if (youtubePlayer && youtubePlayer.getDuration) {
          const duration = youtubePlayer.getDuration();
          const seekTime = (duration * percent) / 100;
          youtubePlayer.seekTo(seekTime, true);
        }
      }

      // Recording seeking
      function seekRecording(percent) {
        if (!window.currentRecordingAudio) {
          console.warn("No recording audio to seek");
          return false;
        }

        const audio = window.currentRecordingAudio;
        const duration = audio.duration;

        console.log(
          "seekRecording called - percent:",
          percent,
          "duration:",
          duration
        );

        if (
          !duration ||
          !isFinite(duration) ||
          isNaN(duration) ||
          duration <= 0
        ) {
          console.warn("Invalid recording duration for seeking:", duration);
          return false;
        }

        const seekTime = Math.max(
          0,
          Math.min(duration, (percent / 100) * duration)
        );

        try {
          // Set seeking flag to prevent timeupdate conflicts
          audio.seeking = true;
          audio.currentTime = seekTime;

          // Update UI immediately
          progressCurrent.style.width = percent + "%";
          progressHandle.style.left = percent + "%";

          if (currentTime) {
            currentTime.textContent = formatTime(seekTime);
          }

          // Clear seeking flag after a short delay
          setTimeout(() => {
            if (audio.seeking) {
              audio.seeking = false;
            }
          }, 100);

          console.log("Recording seek successful to:", seekTime, "seconds");
          return true;
        } catch (error) {
          console.error("Error seeking recording:", error);
          return false;
        }
      }

      // Volume Control
      function setYouTubeVolume(volume) {
        if (youtubePlayer && youtubePlayer.setVolume) {
          youtubePlayer.setVolume(volume);
        }
      }

      // Navigation
      function playNextTrack() {
        // If playing from recording queue
        if (isPlayingRecordingQueue && currentRecordingQueue.length > 0) {
          if (currentRecordingIndex < currentRecordingQueue.length - 1) {
            currentRecordingIndex++;
            playRecording(
              currentRecordingQueue[currentRecordingIndex].id,
              true
            );
            return true;
          } else if (repeatMode === "all") {
            // Loop back to first recording
            currentRecordingIndex = 0;
            playRecording(
              currentRecordingQueue[currentRecordingIndex].id,
              true
            );
            return true;
          }
          return false;
        }

        // YouTube playback
        if (currentSearchResults && currentSearchResults.length > 0) {
          if (currentYouTubeIndex < currentSearchResults.length - 1) {
            currentYouTubeIndex++;
            playYouTubeMusic(currentSearchResults[currentYouTubeIndex]);
            return true;
          }
        }
        return false;
      }

      function playPreviousTrack() {
        // If playing from recording queue
        if (isPlayingRecordingQueue && currentRecordingQueue.length > 0) {
          if (currentRecordingIndex > 0) {
            currentRecordingIndex--;
            playRecording(
              currentRecordingQueue[currentRecordingIndex].id,
              true
            );
          } else if (repeatMode === "all") {
            // Loop to last recording
            currentRecordingIndex = currentRecordingQueue.length - 1;
            playRecording(
              currentRecordingQueue[currentRecordingIndex].id,
              true
            );
          }
          return;
        }

        // YouTube playback
        if (currentSearchResults && currentSearchResults.length > 0) {
          if (currentYouTubeIndex > 0) {
            currentYouTubeIndex--;
            playYouTubeMusic(currentSearchResults[currentYouTubeIndex]);
          }
        }
      }

      // Recording System Functions
      async function initRecordingsDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(
            RECORDINGS_DB_NAME,
            RECORDINGS_DB_VERSION
          );

          request.onerror = () => reject(request.error);
          request.onsuccess = () => {
            recordingsDB = request.result;
            resolve(recordingsDB);
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains("recordings")) {
              const store = db.createObjectStore("recordings", {
                keyPath: "id",
                autoIncrement: true,
              });
              store.createIndex("title", "title", { unique: false });
              store.createIndex("timestamp", "timestamp", { unique: false });
            }
          };
        });
      }

      // Utility function for aggressive screen recording cleanup
      function forceStopScreenRecording() {
        console.log(" FORCE STOP SCREEN RECORDING INITIATED");
        console.log("Current stream state:", currentStream);
        console.log("Current recording state:", isRecording);
        console.log("Current mediaRecorder state:", mediaRecorder);

        if (currentStream) {
          const tracks = currentStream.getTracks();
          console.log(` Found ${tracks.length} tracks to force stop`);

          tracks.forEach((track, index) => {
            try {
              console.log(` Force stopping track ${index + 1}:`, {
                kind: track.kind,
                label: track.label || "unlabeled",
                readyState: track.readyState,
                enabled: track.enabled,
                muted: track.muted,
              });

              // Remove all event listeners
              track.onended = null;
              track.onmute = null;
              track.onunmute = null;

              // Stop the track
              track.stop();

              console.log(
                ` Force stopped track ${index + 1}: ${track.kind} (${
                  track.label || "unlabeled"
                })`
              );

              // Verify it's stopped
              setTimeout(() => {
                console.log(
                  ` Track ${index + 1} final state:`,
                  track.readyState
                );
              }, 50);
            } catch (error) {
              console.error(` Error stopping track ${index + 1}:`, error);
            }
          });

          // Clear stream reference
          console.log(" Clearing stream reference...");
          currentStream = null;
          console.log(" Stream reference cleared");
        } else {
          console.log(" No stream found to force stop");
        }

        // Stop MediaRecorder if still active
        if (mediaRecorder) {
          try {
            console.log(" MediaRecorder state:", mediaRecorder.state);
            if (mediaRecorder.state !== "inactive") {
              console.log(" Force stopping MediaRecorder...");
              mediaRecorder.stop();
              console.log(" MediaRecorder force stopped");
            } else {
              console.log(" MediaRecorder already inactive");
            }
          } catch (error) {
            console.error(" Error stopping MediaRecorder:", error);
          }
          mediaRecorder = null;
          console.log(" MediaRecorder reference cleared");
        } else {
          console.log(" No MediaRecorder to force stop");
        }

        // Reset state
        isRecording = false;
        console.log(" Recording state reset to false");

        console.log(
          " Force stop completed - screen recording should be fully terminated"
        );
      }

      async function startRecording() {
        if (isRecording) return;

        // Detect if this is an iOS device
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

        try {
          let stream;

          if (isIOS) {
            // For iOS devices, use getUserMedia with audio (iOS doesn't support getDisplayMedia with audio)
            stream = await navigator.mediaDevices.getUserMedia({
              audio: {
                echoCancellation: false,
                noiseSuppression: false,
                autoGainControl: false,
                sampleRate: 44100,
              },
            });
          } else {
            // For non-iOS devices, prioritize screen recording with audio
            try {
              // Request screen sharing with audio - this captures browser audio directly
              stream = await navigator.mediaDevices.getDisplayMedia({
                video: {
                  mediaSource: "screen",
                  width: { ideal: 1920 },
                  height: { ideal: 1080 },
                },
                audio: {
                  echoCancellation: false,
                  noiseSuppression: false,
                  autoGainControl: false,
                  sampleRate: 44100,
                },
                selfBrowserSurface: "include", // Allow selecting current tab
                surfaceSwitching: "include", // Allow switching between surfaces
                systemAudio: "include", // Include system audio
              });

              // Extract only the audio track for recording (we don't need video)
              const audioTracks = stream.getAudioTracks();
              if (audioTracks.length === 0) {
                throw new Error("No audio track available from screen capture");
              }

              // Create a new stream with only audio track
              stream = new MediaStream(audioTracks);
            } catch (displayError) {
              console.log(
                "Screen recording failed, trying microphone fallback:",
                displayError
              );

              // Fallback to microphone recording
              stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                  echoCancellation: false,
                  noiseSuppression: false,
                  autoGainControl: false,
                  sampleRate: 44100,
                },
              });
            }
          }

          currentStream = stream;
          recordedChunks = [];

          // Check if the browser supports the preferred codec
          const mimeTypes = [
            "audio/webm;codecs=opus",
            "audio/webm",
            "audio/mp4",
            "audio/mpeg",
          ];

          let supportedMimeType = "";
          for (const mimeType of mimeTypes) {
            if (MediaRecorder.isTypeSupported(mimeType)) {
              supportedMimeType = mimeType;
              break;
            }
          }

          mediaRecorder = new MediaRecorder(currentStream, {
            mimeType: supportedMimeType || undefined,
          });

          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              recordedChunks.push(event.data);
            }
          };

          mediaRecorder.onstop = saveRecording;

          // Handle stream ending (e.g., user stops screen sharing from browser UI)
          currentStream.getVideoTracks().forEach((track) => {
            track.addEventListener("ended", () => {
              console.log("Screen recording ended by user");
              if (isRecording) {
                stopRecording();
              }
            });
          });

          currentStream.getAudioTracks().forEach((track) => {
            track.addEventListener("ended", () => {
              console.log("Audio recording ended");
              if (isRecording) {
                stopRecording();
              }
            });
          });

          mediaRecorder.start(1000); // Collect data every second
          isRecording = true;
          recordingStartTime = Date.now();

          // Update UI
          recordBtn.classList.add("recording");
          recordBtn
            .querySelector("use")
            .setAttribute("href", "#ic-record-stop");
          recordBtn.title = "Stop recording";

          // Update recording status message based on device and recording method
          let statusMessage;
          if (isIOS) {
            statusMessage = " Recording audio... Stay close to speakers!";
          } else {
            // Check if we successfully got screen recording
            const hasVideoTrack = stream.getVideoTracks().length > 0;
            statusMessage = hasVideoTrack
              ? " Recording screen audio... High quality!"
              : " Recording microphone audio...";
          }
          recordingStatus.innerHTML = `${statusMessage} <span id="recordingTimer">0:00</span>`;
          recordingStatus.classList.add("show");

          // Start timer
          recordingTimerInterval = setInterval(updateRecordingTimer, 1000);
        } catch (error) {
          console.error("Error starting recording:", error);

          let errorMessage = "Recording failed. ";

          if (isIOS) {
            errorMessage +=
              "On iPhone/iPad:\n" +
              " Allow microphone access when prompted\n" +
              " Play music at a reasonable volume\n" +
              " Stay close to your device's microphone\n" +
              "Note: iOS records ambient audio through microphone.";
          } else {
            errorMessage +=
              "For best quality screen recording:\n\n" +
              "METHOD 1 - Entire Screen:\n" +
              " Choose 'Entire screen'\n" +
              " Check 'Share audio' checkbox\n" +
              " This captures all system audio\n\n" +
              "METHOD 2 - If current tab not visible:\n" +
              " Open KwikMusic in a NEW TAB\n" +
              " Start recording from the new tab\n" +
              " Select the original music tab\n" +
              " Check 'Share audio' checkbox\n\n" +
              "This captures high-quality browser audio!";
          }

          alert(errorMessage);
        }
      }

      function stopRecording() {
        console.log(" STOP RECORDING CALLED");
        console.log("Current state - isRecording:", isRecording);
        console.log("Current state - mediaRecorder:", mediaRecorder);
        console.log("Current state - currentStream:", currentStream);

        if (!isRecording || !mediaRecorder) {
          console.log(" Early return - not recording or no mediaRecorder");
          return;
        }

        console.log(" MediaRecorder state before stop:", mediaRecorder.state);

        // Stop the MediaRecorder first
        if (mediaRecorder.state !== "inactive") {
          console.log(" Stopping MediaRecorder...");
          mediaRecorder.stop();
          console.log(" MediaRecorder.stop() called");
        } else {
          console.log(" MediaRecorder already inactive");
        }

        // Comprehensive track cleanup to ensure screen recording indicator disappears
        if (currentStream) {
          console.log(" Stopping all tracks in stream...");
          console.log("Stream details:", {
            id: currentStream.id,
            active: currentStream.active,
            trackCount: currentStream.getTracks().length,
          });

          // Get all tracks and stop them individually
          const tracks = currentStream.getTracks();
          tracks.forEach((track, index) => {
            console.log(
              ` Stopping track ${index + 1}/${tracks.length}: ${
                track.kind
              } - ${track.label || "unlabeled"}`
            );
            console.log(`Track ${index + 1} state before stop:`, {
              readyState: track.readyState,
              enabled: track.enabled,
              muted: track.muted,
            });

            // Remove all event listeners before stopping
            track.onended = null;
            track.onmute = null;
            track.onunmute = null;

            // Stop the track
            track.stop();

            // Verify track is stopped
            console.log(
              ` Track ${index + 1} readyState after stop:`,
              track.readyState
            );
          });

          // Additional aggressive cleanup
          try {
            // Clear the stream reference immediately
            const streamToClean = currentStream;
            currentStream = null;
            console.log(" Stream reference cleared");

            // Force garbage collection hint (if available)
            if (window.gc) {
              window.gc();
              console.log(" Garbage collection triggered");
            }

            console.log(` Successfully stopped ${tracks.length} tracks`);
          } catch (error) {
            console.error(" Error during stream cleanup:", error);
          }
        } else {
          console.log(" No currentStream to clean up");
        }

        // Reset recording state
        isRecording = false;
        mediaRecorder = null;
        console.log(" Recording state reset");

        // Update UI
        recordBtn.classList.remove("recording");
        recordBtn.querySelector("use").setAttribute("href", "#ic-record");

        // Set appropriate tooltip based on device
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        recordBtn.title = isIOS
          ? "Record ambient audio (microphone)"
          : "Record high-quality audio (screen capture)";

        recordingStatus.classList.remove("show");

        // Stop timer
        if (recordingTimerInterval) {
          clearInterval(recordingTimerInterval);
          recordingTimerInterval = null;
          console.log(" Recording timer stopped");
        }

        // Add a small delay to allow browser to fully process the track stops
        setTimeout(() => {
          console.log(" First cleanup verification (100ms delay)");
          console.log(
            "Screen recording cleanup completed - indicator should now disappear"
          );

          // Double-check: if screen recording indicator still shows, force stop
          if (currentStream || isRecording) {
            console.log(
              " Screen recording still active, applying force cleanup..."
            );
            forceStopScreenRecording();
          } else {
            console.log(" All clean after first check");
          }
        }, 100);

        // Additional safety: Force cleanup after a longer delay if needed
        setTimeout(() => {
          if (currentStream) {
            console.log(
              " Final safety cleanup - ensuring all tracks are stopped"
            );
            forceStopScreenRecording();
          } else {
            console.log(" Final check passed - no streams remaining");
          }

          // Ultimate nuclear option: try to stop all media streams
          setTimeout(() => {
            console.log(
              " NUCLEAR OPTION: Attempting to stop all possible media streams"
            );
            try {
              // Try to get all media devices and stop them
              if (
                navigator.mediaDevices &&
                navigator.mediaDevices.enumerateDevices
              ) {
                navigator.mediaDevices.enumerateDevices().then((devices) => {
                  console.log(" Available media devices:", devices.length);
                });
              }

              // Try to stop any remaining streams globally
              if (window.speechSynthesis) {
                window.speechSynthesis.cancel();
              }

              // Check if screen recording is still active by attempting to start a new one
              if (
                navigator.mediaDevices &&
                navigator.mediaDevices.getDisplayMedia
              ) {
                console.log(
                  " Testing if screen recording is truly stopped..."
                );
                // This is just a test - we'll immediately stop it
              }

              console.log(" Nuclear cleanup completed");
            } catch (error) {
              console.error(" Nuclear cleanup error:", error);
            }
          }, 1000);
        }, 500);

        console.log(
          " Recording stopped and screen recording ended with enhanced cleanup"
        );
      }

      function updateRecordingTimer() {
        if (!isRecording) return;
        const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
        recordingTimer.textContent = formatTime(elapsed);
      }

      async function saveRecording() {
        if (recordedChunks.length === 0) return;

        const blob = new Blob(recordedChunks, { type: "audio/webm" });
        const currentTrackInfo = getCurrentTrackInfo();

        // Capture artwork if available - enhanced version
        let artworkData = null;
        try {
          // Try multiple sources for artwork
          const artworkSources = [
            document.querySelector(".full-artwork img"),
            document.querySelector(".mini-artwork img"),
            document.querySelector(".artwork img"),
            document.querySelector("img[src*='youtube']"),
            document.querySelector("img[src*='ytimg']"),
            document.querySelector("img[src*='googleusercontent']"),
          ];

          let artworkImg = null;
          for (const source of artworkSources) {
            if (source && source.src && source.src.startsWith("http")) {
              artworkImg = source;
              break;
            }
          }

          if (artworkImg) {
            console.log("Capturing artwork from:", artworkImg.src);
            artworkData = await getImageAsBase64(artworkImg.src);
            if (artworkData) {
              console.log("Artwork captured successfully");
            } else {
              console.log("Failed to convert artwork to base64");
            }
          } else {
            console.log("No suitable artwork image found");
          }
        } catch (error) {
          console.error("Error capturing artwork:", error);
        }

        const recording = {
          title: currentTrackInfo.title || "Unknown Song",
          artist: currentTrackInfo.artist || "Unknown Artist",
          duration: Math.floor((Date.now() - recordingStartTime) / 1000),
          timestamp: Date.now(),
          size: blob.size,
          data: blob,
          artwork: artworkData, // Store artwork as base64
          videoId: currentYouTubeTrack ? currentYouTubeTrack.id : null,
        };

        // Save to IndexedDB
        const transaction = recordingsDB.transaction(
          ["recordings"],
          "readwrite"
        );
        const store = transaction.objectStore("recordings");

        try {
          await store.add(recording);
          console.log("Recording saved successfully");
          await loadRecordings(); // Refresh the recordings list
        } catch (error) {
          console.error("Error saving recording:", error);
        }
      }

      function getCurrentTrackInfo() {
        const titleElement =
          document.querySelector(".full-title") ||
          document.querySelector(".mini-title");
        const artistElement =
          document.querySelector(".full-artist") ||
          document.querySelector(".mini-artist");

        return {
          title: titleElement ? titleElement.textContent : "Unknown Song",
          artist: artistElement ? artistElement.textContent : "Unknown Artist",
        };
      }

      // Helper function to convert image to base64
      async function getImageAsBase64(imageUrl) {
        try {
          // Handle CORS issues by using a proxy approach or canvas method
          const response = await fetch(imageUrl, {
            mode: "cors",
            credentials: "omit",
          });

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const blob = await response.blob();

          // Verify it's an image
          if (!blob.type.startsWith("image/")) {
            throw new Error(`Invalid image type: ${blob.type}`);
          }

          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
              const result = reader.result;
              console.log(
                `Image converted to base64: ${result.substring(0, 50)}...`
              );
              resolve(result);
            };
            reader.onerror = () => {
              console.error("FileReader error:", reader.error);
              reject(reader.error);
            };
            reader.readAsDataURL(blob);
          });
        } catch (error) {
          console.error("Error converting image to base64:", error);

          // Fallback: try using canvas method for same-origin images
          try {
            return await getImageAsBase64Canvas(imageUrl);
          } catch (canvasError) {
            console.error("Canvas fallback also failed:", canvasError);
            return null;
          }
        }
      }

      // Fallback method using canvas for same-origin images
      async function getImageAsBase64Canvas(imageUrl) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = "anonymous";

          img.onload = () => {
            try {
              const canvas = document.createElement("canvas");
              const ctx = canvas.getContext("2d");

              canvas.width = img.width;
              canvas.height = img.height;

              ctx.drawImage(img, 0, 0);

              const dataURL = canvas.toDataURL("image/jpeg", 0.8);
              resolve(dataURL);
            } catch (error) {
              reject(error);
            }
          };

          img.onerror = () => {
            reject(new Error("Failed to load image for canvas conversion"));
          };

          img.src = imageUrl;
        });
      }

      async function loadRecordings() {
        if (!recordingsDB) return;

        const transaction = recordingsDB.transaction(
          ["recordings"],
          "readonly"
        );
        const store = transaction.objectStore("recordings");
        const request = store.getAll();

        request.onsuccess = () => {
          const recordings = request.result.sort(
            (a, b) => b.timestamp - a.timestamp
          );
          displayRecordings(recordings);
          updateRecordingsInfo(recordings);
        };
      }

      async function getAllRecordings() {
        return new Promise((resolve, reject) => {
          if (!recordingsDB) {
            reject(new Error("Recordings database not initialized"));
            return;
          }

          const transaction = recordingsDB.transaction(
            ["recordings"],
            "readonly"
          );
          const store = transaction.objectStore("recordings");
          const request = store.getAll();

          request.onsuccess = () => {
            const recordings = request.result.sort(
              (a, b) => b.timestamp - a.timestamp
            );
            resolve(recordings);
          };

          request.onerror = () => {
            reject(request.error);
          };
        });
      }

      function displayRecordings(recordings) {
        const playAllBtn = document.getElementById("playAllRecordingsBtn");
        const shuffleBtn = document.getElementById("shuffleRecordingsBtn");

        if (recordings.length === 0) {
          recordingsEmpty.style.display = "block";
          recordingsList.innerHTML = "";
          // Hide control buttons when no recordings
          if (playAllBtn) playAllBtn.style.display = "none";
          if (shuffleBtn) shuffleBtn.style.display = "none";
          return;
        }

        // Show control buttons when recordings exist
        if (playAllBtn) playAllBtn.style.display = "block";
        if (shuffleBtn) shuffleBtn.style.display = "block";

        recordingsEmpty.style.display = "none";
        recordingsList.innerHTML = recordings
          .map((recording) => {
            const artworkHtml = recording.artwork
              ? `<img src="${recording.artwork}" alt="${recording.title}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px;">`
              : "";

            return `
          <div class="recording-item" data-id="${recording.id}">
            <div class="recording-artwork">${artworkHtml}</div>
            <div class="recording-info">
              <div class="recording-title">${recording.title}</div>
              <div class="recording-meta">
                <span>${recording.artist}</span>
                <span>${formatTime(recording.duration)}</span>
                <span>${new Date(
                  recording.timestamp
                ).toLocaleDateString()}</span>
              </div>
            </div>
            <div class="recording-actions">
              <button class="recording-btn play-recording" data-id="${
                recording.id
              }">
                <svg class="icon"><use href="#ic-play" /></svg>
              </button>
              <button class="recording-btn delete" data-id="${recording.id}">
                <svg class="icon"><use href="#ic-trash" /></svg>
              </button>
            </div>
          </div>
        `;
          })
          .join("");

        // Add event listeners
        recordingsList.querySelectorAll(".play-recording").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            playRecording(parseInt(btn.dataset.id));
          });
        });

        recordingsList.querySelectorAll(".delete").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            deleteRecording(parseInt(btn.dataset.id));
          });
        });

        // Add click listener to entire recording card
        recordingsList.querySelectorAll(".recording-item").forEach((card) => {
          card.addEventListener("click", async (e) => {
            // Don't trigger if clicking on action buttons
            if (e.target.closest(".recording-actions")) {
              console.log("Clicked on recording actions, ignoring card click");
              return;
            }

            const recordingId = parseInt(card.dataset.id);
            console.log(" Recording card clicked - ID:", recordingId);

            // Add visual feedback
            card.style.opacity = "0.7";

            try {
              // Ensure database is ready
              if (!recordingsDB) {
                console.log(" Database not ready, initializing...");
                await initRecordingsDB();
              }

              console.log(
                " About to call playRecording with ID:",
                recordingId
              );
              await playRecording(recordingId);
              console.log(" playRecording completed successfully");
            } catch (error) {
              console.error(" Error calling playRecording:", error);
              alert("Error playing recording: " + error.message);
            } finally {
              // Reset visual feedback
              card.style.opacity = "1";
            }
          });

          // Add hover effect for better UX
          card.style.cursor = "pointer";
        });
      }

      function updateRecordingsInfo(recordings) {
        const count = recordings.length;
        const totalSize = recordings.reduce((sum, r) => sum + r.size, 0);

        recordingsCount.textContent = `${count} recording${
          count !== 1 ? "s" : ""
        }`;
        recordingsSize.textContent = `${(totalSize / (1024 * 1024)).toFixed(
          1
        )} MB`;

        // Update header button badge
        if (count > 0) {
          recordingsBtn.classList.add("has-recordings");
          recordingsBtn.title = `My Recordings (${count})`;
        } else {
          recordingsBtn.classList.remove("has-recordings");
          recordingsBtn.title = "My Recordings";
        }
      }

      async function playRecording(id, fromQueue = false) {
        console.log(
          " playRecording called with ID:",
          id,
          "fromQueue:",
          fromQueue
        );
        console.log(" recordingsDB state:", recordingsDB);

        // If not called from queue, set up the queue with all recordings
        if (!fromQueue) {
          try {
            console.log(" Setting up recording queue...");
            const allRecordings = await getAllRecordings();
            console.log(
              " Got all recordings:",
              allRecordings.length,
              "items"
            );
            currentRecordingQueue = allRecordings;
            currentRecordingIndex = allRecordings.findIndex((r) => r.id === id);
            isPlayingRecordingQueue = true;
            console.log(
              " Queue setup complete. Index:",
              currentRecordingIndex
            );
          } catch (error) {
            console.error(" Error setting up recording queue:", error);
            return;
          }
        }

        if (!recordingsDB) {
          console.error(" recordingsDB is not initialized");
          alert("Recording database not ready. Please try again.");
          return;
        }

        console.log(" Starting database transaction...");
        const transaction = recordingsDB.transaction(
          ["recordings"],
          "readonly"
        );
        const store = transaction.objectStore("recordings");
        const request = store.get(id);

        request.onsuccess = () => {
          console.log(" Database request successful");
          const recording = request.result;
          console.log(
            " Recording found:",
            recording ? recording.title : "null"
          );

          if (recording) {
            // Stop any current YouTube playback
            if (youtubePlayer && currentYouTubeTrack) {
              youtubePlayer.pauseVideo();
              currentYouTubeTrack = null;
            }

            // Stop any current recording playback
            if (window.currentRecordingAudio) {
              window.currentRecordingAudio.pause();
              window.currentRecordingAudio.currentTime = 0;
              // Clean up previous recording
              if (window.currentAudioUrl) {
                URL.revokeObjectURL(window.currentAudioUrl);
              }
              window.currentRecordingAudio = null;
              window.currentRecording = null;
              window.currentAudioUrl = null;

              // Remove playing class from progress bar
              const progressBar = document.getElementById("progressBar");
              if (progressBar) progressBar.classList.remove("playing");
            }

            // Create audio element for recording playback
            const audioUrl = URL.createObjectURL(recording.data);
            const audio = new Audio(audioUrl);

            console.log(
              "Created audio element for recording:",
              recording.title
            );
            console.log("Audio blob size:", recording.data.size, "bytes");
            console.log("Audio blob type:", recording.data.type);

            // Store reference to current recording audio
            window.currentRecordingAudio = audio;
            window.currentRecording = recording;
            window.currentAudioUrl = audioUrl;

            // Add error handling for audio
            audio.addEventListener("error", (e) => {
              console.error("Audio playback error:", e);
              console.error("Audio error details:", {
                code: audio.error?.code,
                message: audio.error?.message,
                networkState: audio.networkState,
                readyState: audio.readyState,
              });
              alert(
                "Error playing recording. The audio file may be corrupted."
              );
            });

            // Add more detailed load event
            audio.addEventListener("canplay", () => {
              console.log("Audio can start playing:", {
                duration: audio.duration,
                readyState: audio.readyState,
                networkState: audio.networkState,
              });
            });

            // Update all player UI elements
            const miniTitle = document.getElementById("miniTitle");
            const miniArtist = document.getElementById("miniArtist");
            const fullTitle = document.getElementById("fullTitle");
            const fullArtist = document.getElementById("fullArtist");
            const playPauseBtn = document.getElementById("playPauseBtn");
            const miniPlayPauseBtn =
              document.getElementById("miniPlayPauseBtn");

            // Update text content
            if (miniTitle) miniTitle.textContent = recording.title;
            if (miniArtist) miniArtist.textContent = recording.artist;
            if (fullTitle) fullTitle.textContent = recording.title;
            if (fullArtist) fullArtist.textContent = recording.artist;

            // Update artwork if available
            const fullArtwork = document.querySelector(".full-artwork img");
            const miniArtwork = document.querySelector(
              ".mini-artwork-ring img"
            );

            if (recording.artwork) {
              if (fullArtwork) fullArtwork.src = recording.artwork;
              if (miniArtwork) miniArtwork.src = recording.artwork;
            } else {
              // Use default artwork for recordings without images
              const defaultArt =
                "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgdmlld0JveD0iMCAwIDIwMCAyMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIiBmaWxsPSIjNmEwZGFkIi8+Cjx0ZXh0IHg9IjEwMCIgeT0iMTEwIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iNDAiIGZpbGw9IndoaXRlIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj7wn461PC90ZXh0Pgo8L3N2Zz4K";
              if (fullArtwork) fullArtwork.src = defaultArt;
              if (miniArtwork) miniArtwork.src = defaultArt;
            }

            // Update play buttons to pause state
            if (playPauseBtn) {
              playPauseBtn
                .querySelector("use")
                .setAttribute("href", "#ic-pause");
            }
            if (miniPlayPauseBtn) {
              miniPlayPauseBtn
                .querySelector("use")
                .setAttribute("href", "#ic-pause");
            }

            // Show mini player
            const miniPlayer = document.getElementById("miniPlayer");
            if (miniPlayer) miniPlayer.style.display = "block";

            // Set up progress tracking
            const progressBar = document.getElementById("progressBar");
            const progressHandle = document.getElementById("progressHandle");
            const currentTimeEl = document.getElementById("currentTime");
            const totalTimeEl = document.getElementById("totalTime");

            // Add playing class to progress bar for handle visibility
            if (progressBar) progressBar.classList.add("playing");

            // Update total duration
            audio.addEventListener("loadedmetadata", () => {
              const duration = audio.duration;
              console.log("Audio metadata loaded - duration:", duration);

              if (
                duration &&
                isFinite(duration) &&
                !isNaN(duration) &&
                duration > 0
              ) {
                if (totalTimeEl) {
                  totalTimeEl.textContent = formatTime(duration);
                }
                if (totalTime) {
                  totalTime.textContent = formatTime(duration);
                }
                console.log("Duration set to:", formatTime(duration));
              } else {
                console.warn("Invalid audio duration:", duration);
                if (totalTimeEl) {
                  totalTimeEl.textContent = "0:00";
                }
                if (totalTime) {
                  totalTime.textContent = "0:00";
                }
              }
            });

            // Update progress during playback
            audio.addEventListener("timeupdate", () => {
              // Skip updates if we're currently seeking to avoid conflicts
              if (audio.seeking || isDragging) {
                return;
              }

              // Check if audio has valid duration and currentTime
              const duration = audio.duration;
              const currentTimeValue = audio.currentTime;

              if (
                duration &&
                isFinite(duration) &&
                !isNaN(duration) &&
                currentTimeValue >= 0 &&
                isFinite(currentTimeValue) &&
                !isNaN(currentTimeValue)
              ) {
                const progress = Math.max(
                  0,
                  Math.min(100, (currentTimeValue / duration) * 100)
                );

                // Update progress bar elements only if not dragging
                if (!isDragging) {
                  if (progressCurrent) {
                    progressCurrent.style.width = progress + "%";
                  }
                  if (progressHandle) {
                    progressHandle.style.left = progress + "%";
                  }
                }

                // Always update time display
                if (currentTimeEl) {
                  currentTimeEl.textContent = formatTime(currentTimeValue);
                }
                if (currentTime) {
                  currentTime.textContent = formatTime(currentTimeValue);
                }
              } else {
                // Fallback for invalid values
                if (currentTimeEl) {
                  currentTimeEl.textContent = "0:00";
                }
                if (currentTime) {
                  currentTime.textContent = "0:00";
                }
              }
            });

            // Handle audio end
            audio.addEventListener("ended", () => {
              // Reset play buttons
              if (playPauseBtn) {
                playPauseBtn
                  .querySelector("use")
                  .setAttribute("href", "#ic-play");
              }
              if (miniPlayPauseBtn) {
                miniPlayPauseBtn
                  .querySelector("use")
                  .setAttribute("href", "#ic-play");
              }

              // Remove playing class from progress bar
              if (progressBar) progressBar.classList.remove("playing");

              // Clean up current recording
              URL.revokeObjectURL(audioUrl);
              window.currentRecordingAudio = null;
              window.currentRecording = null;
              window.currentAudioUrl = null;

              // Try to play next recording in queue
              if (isPlayingRecordingQueue && currentRecordingQueue.length > 0) {
                if (repeatMode === "one") {
                  // Repeat current recording
                  playRecording(id, true);
                } else {
                  // Try to play next recording
                  const hasNext = playNextTrack();
                  if (!hasNext && repeatMode === "off") {
                    // End of queue, exit recording mode
                    isPlayingRecordingQueue = false;
                    currentRecordingQueue = [];
                    currentRecordingIndex = -1;
                  }
                }
              }
            });

            // Handle audio errors
            audio.addEventListener("error", (e) => {
              console.error("Audio playback error:", e);
              alert("Error playing recording. Please try again.");
            });

            // Start playback
            audio.play().catch((e) => {
              console.error("Failed to start audio playback:", e);
              alert("Could not start playback. Please try again.");
            });
          } else {
            console.error(" Recording not found with ID:", id);
            alert("Recording not found. It may have been deleted.");
          }
        };

        request.onerror = () => {
          console.error(
            " Database error while fetching recording:",
            request.error
          );
          alert("Database error. Please try again.");
        };
      }

      async function deleteRecording(id) {
        if (!confirm("Delete this recording? This action cannot be undone."))
          return;

        const transaction = recordingsDB.transaction(
          ["recordings"],
          "readwrite"
        );
        const store = transaction.objectStore("recordings");

        try {
          await store.delete(id);
          await loadRecordings(); // Refresh the list
        } catch (error) {
          console.error("Error deleting recording:", error);
        }
      }

      // Utility Functions
      function formatTime(seconds) {
        // Handle invalid values
        if (!seconds || !isFinite(seconds) || isNaN(seconds) || seconds < 0) {
          return "0:00";
        }

        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, "0")}`;
      }

      function formatYouTubeDuration(duration) {
        const match = duration.match(/PT(\d+H)?(\d+M)?(\d+S)?/);
        const hours = parseInt(match[1]) || 0;
        const minutes = parseInt(match[2]) || 0;
        const seconds = parseInt(match[3]) || 0;

        if (hours > 0) {
          return `${hours}:${minutes.toString().padStart(2, "0")}:${seconds
            .toString()
            .padStart(2, "0")}`;
        } else {
          return `${minutes}:${seconds.toString().padStart(2, "0")}`;
        }
      }

      // Event Listeners
      // Tabs switching
      function setActiveTab(tab) {
        [tabSearch, tabFavorites, tabPlaylists, tabRecordings].forEach((s) =>
          s.classList.remove("active")
        );
        [tabBtnSearch, tabBtnFavorites, tabBtnPlaylists].forEach((b) =>
          b.classList.remove("active")
        );

        // Get footer-nav for animated indicator
        const footerNav = document.querySelector(".footer-nav");

        // Add transitioning class for glow animation
        if (footerNav) {
          footerNav.classList.add("transitioning");
          // Remove after animation completes
          setTimeout(() => {
            footerNav.classList.remove("transitioning");
          }, 500);
        }

        if (tab === "search") {
          tabSearch.classList.add("active");
          tabBtnSearch.classList.add("active");
          if (footerNav) footerNav.setAttribute("data-active", "0");
        }
        if (tab === "favorites") {
          tabFavorites.classList.add("active");
          tabBtnFavorites.classList.add("active");
          if (footerNav) footerNav.setAttribute("data-active", "1");
          renderFavorites();
          lastNonSearchTab = "favorites";
        }
        if (tab === "playlists") {
          tabPlaylists.classList.add("active");
          tabBtnPlaylists.classList.add("active");
          if (footerNav) footerNav.setAttribute("data-active", "2");
          renderPlaylists();
          lastNonSearchTab = "playlists";
        }
        if (tab === "recordings") {
          tabRecordings.classList.add("active");
          loadRecordings();
          lastNonSearchTab = "recordings";
        }
      }
      tabBtnSearch.addEventListener("click", () => setActiveTab("search"));
      tabBtnFavorites.addEventListener("click", () =>
        setActiveTab("favorites")
      );
      tabBtnPlaylists.addEventListener("click", () =>
        setActiveTab("playlists")
      );

      // Recordings button in header
      recordingsBtn.addEventListener("click", () => setActiveTab("recordings"));

      // Favorites / Playlists data and helpers
      const LS_FAV_KEY = "kwikmusic_favorites_v1";
      const LS_PL_KEY = "kwikmusic_playlists_v1";

      function loadFavorites() {
        try {
          return JSON.parse(localStorage.getItem(LS_FAV_KEY)) || [];
        } catch {
          return [];
        }
      }
      function saveFavorites(list) {
        localStorage.setItem(LS_FAV_KEY, JSON.stringify(list));
      }
      function isFavoriteId(id) {
        return loadFavorites().some((t) => t.id === id);
      }
      function toggleFavorite(track) {
        const favs = loadFavorites();
        const idx = favs.findIndex((t) => t.id === track.id);
        if (idx >= 0) {
          favs.splice(idx, 1);
        } else {
          favs.unshift(track);
        }
        saveFavorites(favs);
        // If favorites tab visible, refresh
        if (tabFavorites.classList.contains("active")) renderFavorites();
      }
      function updateSearchResultFavoriteUI(btn, id) {
        if (isFavoriteId(id)) {
          btn.classList.add("active");
          btn.innerHTML =
            '<svg class="icon"><use href="#ic-heart-fill"/></svg>';
        } else {
          btn.classList.remove("active");
          btn.innerHTML = '<svg class="icon"><use href="#ic-heart"/></svg>';
        }
      }

      function renderFavorites() {
        const favs = loadFavorites();
        favoritesList.innerHTML = "";
        favoritesEmpty.style.display = favs.length ? "none" : "block";
        favs.forEach((track, index) => {
          const item = document.createElement("div");
          item.className = "search-result-item";
          item.innerHTML = `
            <div class="result-thumbnail"><img src="${track.thumbnail}" alt="${
            track.title
          }" onerror="this.src='images/bg.png'"></div>
            <div class="result-info">
              <div class="result-title">${track.title}</div>
              <div class="result-channel">${track.channel}</div>
            </div>
            <div class="result-duration">${track.duration || ""}</div>
            <div class="result-actions">
              <button class="icon-btn heart active" title="Unfavorite"><svg class="icon"><use href="#ic-heart-fill"/></svg></button>
              <button class="icon-btn" title="Add to playlist"><svg class="icon"><use href="#ic-plus"/></svg></button>
            </div>
          `;
          item.addEventListener("click", () => {
            unlockAudioContext(); // Unlock audio on user interaction
            playFromList(favs, index);
          });
          const [favBtn, addBtn] = item.querySelectorAll(
            ".result-actions .icon-btn"
          );
          favBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            toggleFavorite(track);
            renderFavorites();
          });
          addBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            openPlaylistPicker(track);
          });
          favoritesList.appendChild(item);
        });
      }

      function playFromList(list, index) {
        const selected = list[index];
        const queue = applyShuffleIfNeeded(list.slice());
        let startIndex = index;
        if (shuffleEnabled && selected) {
          const found = queue.findIndex((t) => t.id === selected.id);
          startIndex = found >= 0 ? found : 0;
        }
        currentSearchResults = queue;
        currentYouTubeIndex = startIndex;
        playYouTubeMusic(currentSearchResults[currentYouTubeIndex]);
        refreshPrevNextHandlers();
      }

      // Shuffle handling
      let shuffleEnabled = false;
      let lastLinearList = null;
      function shuffleArray(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }
      function setShuffle(on) {
        shuffleEnabled = on;
        const shuffleBtnEl = document.getElementById("shuffleBtn");
        if (shuffleBtnEl) shuffleBtnEl.classList.toggle("active", on);
        // If toggled during playback, rebuild queue but keep current track on top
        if (
          currentSearchResults &&
          currentSearchResults.length > 0 &&
          currentYouTubeIndex >= 0
        ) {
          const current = currentSearchResults[currentYouTubeIndex];
          const rest = currentSearchResults.filter(
            (_, i) => i !== currentYouTubeIndex
          );
          const newQueue = on
            ? [current, ...shuffleArray(rest)]
            : [current, ...rest];
          currentSearchResults = newQueue;
          currentYouTubeIndex = 0;
        }
        refreshPrevNextHandlers();
      }
      function applyShuffleIfNeeded(arr) {
        if (!shuffleEnabled) return arr;
        return shuffleArray(arr);
      }

      // Playlists
      function loadPlaylists() {
        try {
          return JSON.parse(localStorage.getItem(LS_PL_KEY)) || [];
        } catch {
          return [];
        }
      }
      function savePlaylists(pls) {
        localStorage.setItem(LS_PL_KEY, JSON.stringify(pls));
      }
      function deletePlaylist(id) {
        const pls = loadPlaylists();
        const idx = pls.findIndex((p) => p.id === id);
        if (idx >= 0) {
          pls.splice(idx, 1);
          savePlaylists(pls);
        }
      }
      function createPlaylist(name) {
        const pls = loadPlaylists();
        const id = "pl_" + Date.now();
        pls.push({ id, name, tracks: [] });
        savePlaylists(pls);
        return id;
      }
      function renamePlaylist(id, newName) {
        const trimmed = (newName || "").trim();
        if (!trimmed) return;
        const pls = loadPlaylists();
        const p = pls.find((pl) => pl.id === id);
        if (p) {
          p.name = trimmed;
          savePlaylists(pls);
        }
      }
      function addTrackToPlaylist(playlistId, track) {
        const pls = loadPlaylists();
        const p = pls.find((p) => p.id === playlistId);
        if (!p) return;
        if (!p.tracks.some((t) => t.id === track.id)) {
          p.tracks.unshift(track);
          savePlaylists(pls);
        }
      }
      function removeTrackFromPlaylist(playlistId, trackId) {
        const pls = loadPlaylists();
        const p = pls.find((p) => p.id === playlistId);
        if (!p) return;
        p.tracks = p.tracks.filter((t) => t.id !== trackId);
        savePlaylists(pls);
      }
      function renderPlaylists() {
        const pls = loadPlaylists();
        playlistsList.innerHTML = "";
        playlistsEmpty.style.display = pls.length ? "none" : "block";
        playlistDetail.style.display = "none";
        document.getElementById("playlistsView").style.display = "block";
        pls.forEach((pl) => {
          const el = document.createElement("div");
          el.className = "playlist-item";
          let thumbs = (pl.tracks || [])
            .slice(0, 4)
            .map((t) => t.thumbnail || "images/bg.png");
          if (thumbs.length === 0) thumbs = ["images/bg.png"]; // fallback
          const thumbImgs = thumbs
            .map(
              (src, i) =>
                `<img src="${src}" alt="" onerror="this.src='images/bg.png'" style="left:${
                  i * 36
                }px; z-index:${i + 1}">`
            )
            .join("");
          el.innerHTML = `
            <div class="playlist-thumb-stack">${thumbImgs}</div>
            <div class="playlist-card-info">
              <div>
                <div class="playlist-name">${pl.name}</div>
                <div class="playlist-chip">${pl.tracks.length} tracks</div>
              </div>
              <div class="playlist-actions">
                <button class="icon-btn small" data-act="play" title="Play all"><svg class="icon"><use href="#ic-play"/></svg></button>
                <button class="icon-btn small" data-act="shuffle" title="Shuffle"><svg class="icon"><use href="#ic-shuffle"/></svg></button>
              </div>
            </div>`;
          // Dynamic gradient theming
          if (pl.tracks && pl.tracks[0] && pl.tracks[0].thumbnail) {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = () => {
              try {
                const c = document.createElement("canvas");
                const ctx = c.getContext("2d");
                const S = 20;
                c.width = c.height = S;
                ctx.drawImage(img, 0, 0, S, S);
                let r = 0,
                  g = 0,
                  b = 0,
                  cnt = 0;
                const data = ctx.getImageData(0, 0, S, S).data;
                for (let i = 0; i < data.length; i += 4) {
                  const rr = data[i],
                    gg = data[i + 1],
                    bb = data[i + 2];
                  const maxc = Math.max(rr, gg, bb),
                    minc = Math.min(rr, gg, bb);
                  if (maxc > 245 || minc < 15) continue;
                  r += rr;
                  g += gg;
                  b += bb;
                  cnt++;
                }
                if (cnt > 5) {
                  r = Math.round(r / cnt);
                  g = Math.round(g / cnt);
                  b = Math.round(b / cnt);
                  const r2 = Math.min(255, r + 40),
                    g2 = Math.min(255, g + 40),
                    b2 = Math.min(255, b + 60);
                  el.style.background = `linear-gradient(135deg, rgba(${r},${g},${b},0.45), rgba(${r2},${g2},${b2},0.18))`;
                  el.style.border = `1px solid rgba(${r},${g},${b},0.35)`;
                  el.style.boxShadow = `0 10px 28px -8px rgba(${r},${g},${b},0.42)`;
                }
              } catch {}
            };
            img.src = pl.tracks[0].thumbnail;
          }
          // Clicking card opens playlist
          el.addEventListener("click", () => openPlaylist(pl.id));
          playlistsList.appendChild(el);
          // Prevent inner buttons from triggering open, and wire actions
          el.querySelectorAll(".playlist-actions .icon-btn").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              e.stopPropagation();
              const act = btn.getAttribute("data-act");
              if (act === "play") {
                setActiveTab("playlists");
                setShuffle(false);
                if (pl.tracks.length) playFromList(pl.tracks, 0);
              } else if (act === "shuffle") {
                setActiveTab("playlists");
                setShuffle(true);
                if (pl.tracks.length) {
                  const rand = Math.floor(Math.random() * pl.tracks.length);
                  playFromList(pl.tracks, rand);
                }
              }
              showMiniPlayer();
            });
          });
        });
      }
      function openPlaylist(id) {
        const pls = loadPlaylists();
        const p = pls.find((p) => p.id === id);
        if (!p) return;
        currentOpenPlaylistId = p.id;
        document.getElementById("playlistsView").style.display = "none";
        playlistDetail.style.display = "block";
        playlistDetailTitle.textContent = p.name;
        playlistTracks.innerHTML = "";
        // Wire delete button
        const delBtn = document.getElementById("playlistDeleteBtn");
        if (delBtn) {
          delBtn.onclick = () => {
            const yes = confirm(
              `Delete playlist "${p.name}"? This cannot be undone.`
            );
            if (yes) {
              deletePlaylist(p.id);
              // Return to playlists view
              renderPlaylists();
            }
          };
        }
        const tracks = p.tracks.slice();
        p.tracks.forEach((track, index) => {
          const item = document.createElement("div");
          item.className = "search-result-item";
          item.innerHTML = `
            <div class=\"result-thumbnail\"><img src=\"${
              track.thumbnail
            }\" alt=\"${
            track.title
          }\" onerror=\"this.src='images/bg.png'\"></div>
            <div class=\"result-info\">
              <div class=\"result-title\">${track.title}</div>
              <div class=\"result-channel\">${track.channel}</div>
            </div>
            <div class=\"result-duration\">${track.duration || ""}</div>
            <div class=\"result-actions\">
              <button class=\"icon-btn\" title=\"Remove from playlist\"><svg class=\"icon\"><use href=\"#ic-trash\"/></svg></button>
            </div>
          `;
          item.addEventListener("click", () => {
            unlockAudioContext(); // Unlock audio on user interaction
            playFromList(p.tracks, index);
          });
          const removeBtn = item.querySelector(".result-actions .icon-btn");
          removeBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            removeTrackFromPlaylist(p.id, track.id);
            openPlaylist(p.id);
          });
          playlistTracks.appendChild(item);
        });
        // Back
        playlistBackBtn.onclick = () => renderPlaylists();

        // Actions: Play All / Shuffle
        playlistPlayAllBtn.onclick = () => {
          setActiveTab("playlists");
          setShuffle(false);
          playFromList(p.tracks, 0);
          showMiniPlayer();
        };
        playlistShuffleBtn.onclick = () => {
          setActiveTab("playlists");
          setShuffle(true);
          if (p.tracks.length) {
            const rand = Math.floor(Math.random() * p.tracks.length);
            playFromList(p.tracks, rand);
          }
          showMiniPlayer();
        };
      }

      // Overlay handlers
      let pendingTrackForPlaylist = null;
      function openPlaylistPicker(track) {
        pendingTrackForPlaylist = track;
        const pls = loadPlaylists();
        playlistChoices.innerHTML = "";
        if (pls.length === 0) {
          const info = document.createElement("div");
          info.className = "list-empty";
          info.style.padding = "12px 0";
          info.textContent = "No playlists yet. Create one to add this song.";
          playlistChoices.appendChild(info);
        } else {
          pls.forEach((pl) => {
            const row = document.createElement("div");
            row.className = "sheet-row";
            row.innerHTML = `<div><strong>${pl.name}</strong><div style=\"color:rgba(255,255,255,0.6); font-size:12px;\">${pl.tracks.length} tracks</div></div><div><svg class=\"icon\"><use href=\"#ic-plus\"/></svg></div>`;
            row.addEventListener("click", () => {
              addTrackToPlaylist(pl.id, track);
              closeOverlay();
            });
            playlistChoices.appendChild(row);
          });
        }
        playlistOverlay.style.display = "flex";
      }
      function closeOverlay() {
        playlistOverlay.style.display = "none";
        pendingTrackForPlaylist = null;
      }
      closePlaylistOverlay.addEventListener("click", closeOverlay);
      playlistOverlay.addEventListener("click", (e) => {
        if (e.target === playlistOverlay) closeOverlay();
      });
      function openCreatePlaylist(onCreate) {
        createPlaylistOverlay.style.display = "flex";
        playlistNameInput.value = "";
        playlistNameInput.focus();
        const cleanup = () => {
          createPlaylistOverlay.style.display = "none";
          confirmCreatePlaylist.onclick = null;
          cancelCreatePlaylist.onclick = null;
        };
        confirmCreatePlaylist.onclick = () => {
          const name = playlistNameInput.value.trim();
          if (!name) return;
          const id = createPlaylist(name);
          if (typeof onCreate === "function") onCreate(id);
          cleanup();
          renderPlaylists();
        };
        cancelCreatePlaylist.onclick = cleanup;
        // clicking outside to close
        createPlaylistOverlay.addEventListener(
          "click",
          (e) => {
            if (e.target === createPlaylistOverlay) {
              cleanup();
            }
          },
          { once: true }
        );
      }
      createPlaylistInline.addEventListener("click", () => {
        openCreatePlaylist((id) => {
          if (pendingTrackForPlaylist)
            addTrackToPlaylist(id, pendingTrackForPlaylist);
          closeOverlay();
        });
      });

      newPlaylistBtn.addEventListener("click", () => {
        openCreatePlaylist();
      });
      searchBtn.addEventListener("click", () => {
        const query = searchInput.value.trim();
        if (query) {
          searchYouTube(query);
        } else {
          // No query, show suggestions
          renderSuggestions();
          searchResults.innerHTML = `
            <div class="welcome-message">
              <h2>Welcome to KwikMusic</h2>
              <p>Find your next favorite track and start listening.</p>
            </div>
          `;
          searchSuggestions.style.display = "block";
        }
      });

      searchInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          const query = searchInput.value.trim();
          if (query) {
            searchYouTube(query);
          } else {
            renderSuggestions();
            searchResults.innerHTML = `
              <div class="welcome-message">
                <h2>Welcome to KwikMusic</h2>
                <p>Find your next favorite track and start listening.</p>
              </div>`;
            searchSuggestions.style.display = "block";
          }
        }
      });

      // Mini player click to show full player
      miniPlayer.addEventListener("click", (e) => {
        if (!e.target.closest(".mini-controls")) {
          showFullPlayer();
        }
      });

      // Back button to hide full player
      backBtn.addEventListener("click", hideFullPlayer);

      // Play/Pause buttons
      miniPlayPauseBtn.addEventListener("click", (e) => {
        e.stopPropagation();

        // Unlock audio on user interaction (critical for PWA)
        unlockAudioContext();

        // Check if we're playing a recording
        if (window.currentRecordingAudio) {
          if (window.currentRecordingAudio.paused) {
            window.currentRecordingAudio.play();
            miniPlayPauseBtn
              .querySelector("use")
              .setAttribute("href", "#ic-pause");
            playPauseBtn.querySelector("use").setAttribute("href", "#ic-pause");
          } else {
            window.currentRecordingAudio.pause();
            miniPlayPauseBtn
              .querySelector("use")
              .setAttribute("href", "#ic-play");
            playPauseBtn.querySelector("use").setAttribute("href", "#ic-play");
          }
          return;
        }

        // YouTube logic with PWA retry
        if (currentYouTubeTrack && youtubePlayer) {
          try {
            const state = youtubePlayer.getPlayerState();
            if (state === YT.PlayerState.PLAYING) {
              lastPauseByUser = true;
              youtubePlayer.pauseVideo();
            } else {
              lastPauseByUser = false;
              youtubePlayer.playVideo();

              // PWA fix: Retry play if it doesn't start
              setTimeout(() => {
                try {
                  const newState = youtubePlayer.getPlayerState();
                  if (
                    newState !== YT.PlayerState.PLAYING &&
                    newState !== YT.PlayerState.BUFFERING &&
                    !lastPauseByUser
                  ) {
                    console.log("PWA: Retrying playback on button click");
                    youtubePlayer.playVideo();
                  }
                } catch (err) {
                  console.warn("Play retry error:", err);
                }
              }, 300);
            }
          } catch (err) {
            console.error("Play/pause error:", err);
          }
        }
      });

      playPauseBtn.addEventListener("click", () => {
        // Unlock audio on user interaction (critical for PWA)
        unlockAudioContext();

        // Check if we're playing a recording
        if (window.currentRecordingAudio) {
          if (window.currentRecordingAudio.paused) {
            window.currentRecordingAudio.play();
            playPauseBtn.querySelector("use").setAttribute("href", "#ic-pause");
            miniPlayPauseBtn
              .querySelector("use")
              .setAttribute("href", "#ic-pause");
          } else {
            window.currentRecordingAudio.pause();
            playPauseBtn.querySelector("use").setAttribute("href", "#ic-play");
            miniPlayPauseBtn
              .querySelector("use")
              .setAttribute("href", "#ic-play");
          }
          return;
        }

        // YouTube logic with PWA retry
        if (currentYouTubeTrack && youtubePlayer) {
          try {
            const state = youtubePlayer.getPlayerState();
            if (state === YT.PlayerState.PLAYING) {
              lastPauseByUser = true;
              youtubePlayer.pauseVideo();
            } else {
              lastPauseByUser = false;
              youtubePlayer.playVideo();

              // PWA fix: Retry play if it doesn't start
              setTimeout(() => {
                try {
                  const newState = youtubePlayer.getPlayerState();
                  if (
                    newState !== YT.PlayerState.PLAYING &&
                    newState !== YT.PlayerState.BUFFERING &&
                    !lastPauseByUser
                  ) {
                    console.log("PWA: Retrying playback on button click");
                    youtubePlayer.playVideo();
                  }
                } catch (err) {
                  console.warn("Play retry error:", err);
                }
              }, 300);
            }
          } catch (err) {
            console.error("Play/pause error:", err);
          }
        }
      });

      // Record button
      recordBtn.addEventListener("click", () => {
        if (isRecording) {
          stopRecording();
        } else {
          if (!currentYouTubeTrack) {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const message = isIOS
              ? "Please play a song first.\n\nNote: iPhone will record ambient audio through microphone."
              : "Please play a song first.\n\nTip: Choose 'Entire screen' or open in a new tab for screen recording. Make sure to select 'Share audio'!";
            alert(message);
            return;
          }
          startRecording();
        }
      });

      // Play All Recordings button
      document
        .getElementById("playAllRecordingsBtn")
        .addEventListener("click", async () => {
          try {
            const recordings = await getAllRecordings();
            if (recordings.length > 0) {
              // Set up recording queue
              currentRecordingQueue = recordings;
              currentRecordingIndex = 0;
              isPlayingRecordingQueue = true;
              // Play the first recording
              playRecording(recordings[0].id, true);
            }
          } catch (error) {
            console.error("Error playing all recordings:", error);
          }
        });

      // Shuffle Recordings button
      document
        .getElementById("shuffleRecordingsBtn")
        .addEventListener("click", async () => {
          try {
            const recordings = await getAllRecordings();
            if (recordings.length > 0) {
              // Shuffle the recordings array
              const shuffledRecordings = [...recordings].sort(
                () => Math.random() - 0.5
              );
              // Set up shuffled recording queue
              currentRecordingQueue = shuffledRecordings;
              currentRecordingIndex = 0;
              isPlayingRecordingQueue = true;
              // Play the first recording from shuffled list
              playRecording(shuffledRecordings[0].id, true);
            }
          } catch (error) {
            console.error("Error shuffling recordings:", error);
          }
        });

      // Full player more button: quick actions
      document.getElementById("moreBtn").addEventListener("click", () => {
        if (!currentYouTubeTrack) return;
        const isFav = isFavoriteId(currentYouTubeTrack.id);
        const action = confirm(
          (isFav ? "Remove from" : "Add to") +
            " favorites? Click Cancel to add to a playlist."
        );
        if (action) {
          toggleFavorite(currentYouTubeTrack);
        } else {
          openPlaylistPicker(currentYouTubeTrack);
        }
      });

      // Header rain toggle
      if (rainToggleBtn) {
        rainToggleBtn.addEventListener("click", (e) => {
          e.preventDefault();
          setRain(!isRainOn);
        });
      }

      // Navigation buttons
      prevBtn.addEventListener("click", playPreviousTrack);
      nextBtn.addEventListener("click", playNextTrack);
      // Shuffle toggle from full player
      document.getElementById("shuffleBtn").addEventListener("click", () => {
        setShuffle(!shuffleEnabled);
      });
      // Repeat toggle cycle: off -> all -> one -> off
      document.getElementById("repeatBtn").addEventListener("click", () => {
        if (repeatMode === "off") repeatMode = "all";
        else if (repeatMode === "all") repeatMode = "one";
        else repeatMode = "off";
        const btn = document.getElementById("repeatBtn");
        btn.classList.toggle("active", repeatMode !== "off");
        btn.classList.toggle("repeat-one", repeatMode === "one");
      });

      // Progress bar interaction
      progressBar.addEventListener("click", (e) => {
        const rect = progressBar.getBoundingClientRect();
        const percent = Math.max(
          0,
          Math.min(100, ((e.clientX - rect.left) / rect.width) * 100)
        );

        console.log("Progress bar clicked - percent:", percent);

        // Check if we're playing a recording
        if (window.currentRecordingAudio) {
          seekRecording(percent);
          return;
        }

        // Original YouTube logic
        if (currentYouTubeTrack) {
          seekYouTube(percent);
        }
      });

      // Volume slider interaction
      volumeSlider.addEventListener("click", (e) => {
        if (currentYouTubeTrack) {
          const rect = volumeSlider.getBoundingClientRect();
          const percent = (e.clientX - rect.left) / rect.width;
          volumeLevel.style.width = percent * 100 + "%";
          volumeHandle.style.left = percent * 100 + "%";
          setYouTubeVolume(percent * 100);
        }
      });

      // Touch/drag support for progress and volume
      let isDragging = false;
      let dragTarget = null;

      function handleTouchStart(e, type) {
        isDragging = true;
        dragTarget = type;
        if (type === "progress") {
          progressBar.classList.add("dragging");
        } else if (type === "volume") {
          volumeSlider.classList.add("dragging");
        }
      }

      function handleTouchMove(e) {
        if (!isDragging) return;

        // Allow dragging for both YouTube tracks and recordings
        const hasYouTube = currentYouTubeTrack;
        const hasRecording = window.currentRecordingAudio;

        if (!hasYouTube && !hasRecording) return;

        e.preventDefault();
        const touch = e.touches[0] || e;

        if (dragTarget === "progress") {
          const rect = progressBar.getBoundingClientRect();
          const percent = Math.max(
            0,
            Math.min(100, ((touch.clientX - rect.left) / rect.width) * 100)
          );
          progressCurrent.style.width = percent + "%";
          progressHandle.style.left = percent + "%";

          // Update time display during drag for recordings
          if (hasRecording) {
            const duration = window.currentRecordingAudio.duration;
            if (duration && isFinite(duration)) {
              const previewTime = (percent / 100) * duration;
              if (currentTime) {
                currentTime.textContent = formatTime(previewTime);
              }
            }
          }
        } else if (dragTarget === "volume") {
          const rect = volumeSlider.getBoundingClientRect();
          const percent = Math.max(
            0,
            Math.min(100, ((touch.clientX - rect.left) / rect.width) * 100)
          );
          volumeLevel.style.width = percent + "%";
          volumeHandle.style.left = percent + "%";
          setYouTubeVolume(percent);
        }
      }

      function handleTouchEnd(e) {
        if (isDragging) {
          if (dragTarget === "progress") {
            const percent = parseFloat(progressCurrent.style.width);

            // Check if we're playing a recording
            if (window.currentRecordingAudio) {
              seekRecording(percent);
            } else if (currentYouTubeTrack) {
              seekYouTube(percent);
            }
            progressBar.classList.remove("dragging");
          } else if (dragTarget === "volume") {
            volumeSlider.classList.remove("dragging");
          }
        }
        isDragging = false;
        dragTarget = null;
      }

      // Add touch/mouse event listeners
      progressBar.addEventListener(
        "touchstart",
        (e) => handleTouchStart(e, "progress"),
        { passive: false }
      );
      progressBar.addEventListener("mousedown", (e) =>
        handleTouchStart(e, "progress")
      );

      volumeSlider.addEventListener(
        "touchstart",
        (e) => handleTouchStart(e, "volume"),
        { passive: false }
      );
      volumeSlider.addEventListener("mousedown", (e) =>
        handleTouchStart(e, "volume")
      );

      document.addEventListener("touchmove", handleTouchMove);
      document.addEventListener("mousemove", handleTouchMove);

      document.addEventListener("touchend", handleTouchEnd);
      document.addEventListener("mouseup", handleTouchEnd);

      // Initialize
      loadYouTubeAPI();
      window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady;
      setupMediaSessionHandlers();

      // Global audio unlock for PWA - triggers on first user interaction
      let globalAudioUnlocked = false;
      const globalUnlockEvents = ['touchstart', 'touchend', 'click', 'keydown'];
      
      function globalAudioUnlock() {
        if (globalAudioUnlocked) return;
        
        console.log(" Global audio unlock triggered");
        unlockAudioContext();
        
        // Also try to interact with YouTube player to unlock it
        if (youtubePlayer && isPlayerReady) {
          try {
            youtubePlayer.setVolume(100);
            youtubePlayer.unMute();
          } catch (err) {
            console.warn("YouTube player unlock error:", err);
          }
        }
        
        globalAudioUnlocked = true;
        
        // Remove listeners after first successful unlock
        globalUnlockEvents.forEach(event => {
          document.removeEventListener(event, globalAudioUnlock);
        });
      }
      
      // Attach global unlock listeners
      globalUnlockEvents.forEach(event => {
        document.addEventListener(event, globalAudioUnlock, { once: true, passive: true });
      });

      // Background/minimize handling: remember if we were playing and try to resume when possible
      let wasPlayingOnHide = false;
      let bgResumeAttempted = false;
      document.addEventListener("visibilitychange", () => {
        try {
          const state = youtubePlayer?.getPlayerState?.();
          if (document.visibilityState === "hidden") {
            wasPlayingOnHide = state === YT.PlayerState.PLAYING;
            bgResumeAttempted = false;
          } else if (document.visibilityState === "visible") {
            // If we were playing before hide and it's now paused, resume
            if (
              wasPlayingOnHide &&
              state !== YT.PlayerState.PLAYING &&
              !lastPauseByUser
            ) {
              setTimeout(() => {
                try {
                  if (!lastPauseByUser) youtubePlayer?.playVideo?.();
                } catch {}
              }, 100);
            }
            wasPlayingOnHide = false;
            if (bgResumeTimer) {
              clearInterval(bgResumeTimer);
              bgResumeTimer = null;
              bgResumeTries = 0;
            }
          }
        } catch {}
      });
      // Initial renders
      renderFavorites();
      renderPlaylists();
      renderSuggestions();

      // Enable inline rename for playlist title
      (function enablePlaylistRename() {
        if (!playlistDetailTitle) return;
        playlistDetailTitle.addEventListener("click", () => {
          if (!currentOpenPlaylistId) return;
          if (!playlistDetailTitle.isContentEditable) {
            playlistDetailTitle.contentEditable = "true";
            const range = document.createRange();
            range.selectNodeContents(playlistDetailTitle);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
          }
        });
        playlistDetailTitle.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            playlistDetailTitle.blur();
          } else if (e.key === "Escape") {
            e.preventDefault();
            const pls = loadPlaylists();
            const p = pls.find((pl) => pl.id === currentOpenPlaylistId);
            if (p) playlistDetailTitle.textContent = p.name;
            playlistDetailTitle.blur();
          }
        });
        playlistDetailTitle.addEventListener("blur", () => {
          if (!playlistDetailTitle.isContentEditable) return;
          playlistDetailTitle.contentEditable = "false";
          const newName = playlistDetailTitle.textContent.trim();
          if (!currentOpenPlaylistId) return;
          if (newName) {
            renamePlaylist(currentOpenPlaylistId, newName);
            renderPlaylists();
          } else {
            const pls = loadPlaylists();
            const p = pls.find((pl) => pl.id === currentOpenPlaylistId);
            if (p) playlistDetailTitle.textContent = p.name;
          }
        });
      })();

      // Typewriter placeholder animation for search input
      (function setupTypewriterPlaceholder() {
        const samples = [
          "Saiyaraa",
          "Afsanay",
          "Shape of You",
          "Tum Hi Ho",
          "Kesariya",
          "Sanson ki Mala",
          "Perfect",
        ];
        let si = 0,
          ci = 0,
          dir = 1; // dir: 1 typing, -1 deleting
        let twTimer = null;
        let pausedByUser = false;

        function step() {
          if (
            !searchInput ||
            document.activeElement === searchInput ||
            pausedByUser
          )
            return;
          const word = samples[si];
          ci += dir;
          if (ci >= word.length + 8) {
            // small dwell after full word
            dir = -1;
          } else if (ci <= 0) {
            dir = 1;
            si = (si + 1) % samples.length;
          }
          const shown = word.slice(0, Math.max(0, Math.min(word.length, ci)));
          searchInput.setAttribute("placeholder", shown || "Type to search...");
        }
        function start() {
          if (twTimer) clearInterval(twTimer);
          twTimer = setInterval(step, 120);
        }
        function stop() {
          if (twTimer) {
            clearInterval(twTimer);
            twTimer = null;
          }
        }

        searchInput.addEventListener("focus", () => {
          pausedByUser = true;
          stop();
        });
        searchInput.addEventListener("blur", () => {
          pausedByUser = false;
          if (!searchInput.value.trim()) {
            searchInput.setAttribute("placeholder", "Type to search...");
            start();
          }
        });
        searchInput.addEventListener("input", () => {
          if (searchInput.value.trim()) {
            pausedByUser = true;
            stop();
          } else if (!document.activeElement === searchInput) {
            pausedByUser = false;
            start();
          }
        });

        start();
      })();

      // Global swipe navigation between tabs & back from playlist detail
      (function enableGlobalSwipeNavigation() {
        const container = document.querySelector(".main-content");
        if (!container) return;
        const hintL = document.getElementById("swipeHintEdgeLeft");
        const hintR = document.getElementById("swipeHintEdgeRight");
        // NOTE: Right swipe from left edge on Search now behaves as a 2-step back:
        // 1) Clears search input/results and restores welcome + suggestions.
        // 2) If already clear, navigates to the last non-search tab the user visited.
        let sx = 0,
          sy = 0,
          cx = 0,
          cy = 0,
          tracking = false,
          axis = null,
          moved = false;
        const H_THRESHOLD = 70; // px needed for horizontal navigation
        const EDGE_BACK_WIDTH = 30; // left edge width for back gesture

        function getActiveTab() {
          if (tabSearch.classList.contains("active")) return "search";
          if (tabFavorites.classList.contains("active")) return "favorites";
          if (tabPlaylists.classList.contains("active")) return "playlists";
          return "search";
        }
        function navigateRelative(delta) {
          const order = ["search", "favorites", "playlists"];
          const cur = getActiveTab();
          const idx = order.indexOf(cur);
          const next = order[idx + delta];
          if (next) {
            setActiveTab(next);
          }
        }
        function playlistDetailVisible() {
          return playlistDetail && playlistDetail.style.display !== "none";
        }
        function onStart(e) {
          // Ignore if full player open
          if (fullPlayer && fullPlayer.classList.contains("active")) return;
          const t = e.touches ? e.touches[0] : e;
          sx = cx = t.clientX;
          sy = cy = t.clientY;
          tracking = true;
          axis = null;
          moved = false;
          if (hintL) hintL.style.opacity = "0";
          if (hintR) hintR.style.opacity = "0";
        }
        function onMove(e) {
          if (!tracking) return;
          const t = e.touches ? e.touches[0] : e;
          cx = t.clientX;
          cy = t.clientY;
          const dx = cx - sx;
          const dy = cy - sy;
          if (!axis) {
            if (Math.abs(dx) > 12 || Math.abs(dy) > 12) {
              axis = Math.abs(dx) > Math.abs(dy) ? "x" : "y";
            } else return;
          }
          if (axis === "x") {
            // Prevent vertical scroll while deciding horizontal nav
            if (e.cancelable) e.preventDefault();
            moved = true;
            const adx = Math.abs(dx);
            const progress = Math.min(1, adx / H_THRESHOLD);
            if (dx < 0) {
              // moving left -> next
              if (hintR) {
                hintR.querySelector(".hint-label").textContent = "Next";
                hintR.style.opacity = String(progress * 0.95);
              }
              if (hintL) hintL.style.opacity = "0";
            } else if (dx > 0) {
              // moving right -> prev/back
              if (hintL) {
                const label = playlistDetailVisible() ? "Back" : "Prev";
                hintL.querySelector(".hint-label").textContent = label;
                // Emphasize if from edge
                const edgeFactor = sx < EDGE_BACK_WIDTH ? 1 : 0.7;
                hintL.style.opacity = String(progress * 0.95 * edgeFactor);
              }
              if (hintR) hintR.style.opacity = "0";
            }
          }
        }
        function onEnd() {
          if (!tracking) {
            return;
          }
          const dx = cx - sx;
          const dy = cy - sy;
          if (axis === "x" && Math.abs(dx) > Math.abs(dy)) {
            if (playlistDetailVisible()) {
              // Back swipe from left edge
              if (dx > H_THRESHOLD / 2 && sx < EDGE_BACK_WIDTH) {
                renderPlaylists();
              }
            } else {
              if (dx <= -H_THRESHOLD) {
                // swipe left -> next tab
                navigateRelative(1);
              } else if (dx >= H_THRESHOLD) {
                // swipe right -> previous tab OR search back gesture
                const active = getActiveTab();
                if (active === "search" && sx < EDGE_BACK_WIDTH) {
                  // Determine if search has results/content to clear
                  const hasQuery = searchInput.value.trim().length > 0;
                  const hasResults =
                    searchResults &&
                    searchResults.children.length > 0 &&
                    !searchResults.querySelector(".welcome-message");
                  const suggestionsVisible =
                    searchSuggestions &&
                    searchSuggestions.style.display !== "none";
                  if (hasQuery || hasResults) {
                    // Clear search UI and restore welcome + suggestions (first back stage)
                    searchInput.value = "";
                    renderSuggestions();
                    searchResults.innerHTML = `\n              <div class="welcome-message">\n                <h2>Welcome to KwikMusic</h2>\n                <p>Find your next favorite track and start listening.</p>\n              </div>\n            `;
                    if (searchSuggestions)
                      searchSuggestions.style.display = "block";
                  } else if (!hasQuery && !hasResults && suggestionsVisible) {
                    // Second stage: go back to last non-search tab
                    setActiveTab(lastNonSearchTab || "favorites");
                  } else {
                    // Fallback: previous tab
                    navigateRelative(-1);
                  }
                } else {
                  navigateRelative(-1);
                }
              } else if (
                dx > 40 &&
                sx < EDGE_BACK_WIDTH &&
                getActiveTab() !== "search"
              ) {
                // Edge back also acts as previous tab if not enough full threshold
                navigateRelative(-1);
              }
            }
          }
          tracking = false;
          axis = null;
          moved = false;
          if (hintL) hintL.style.opacity = "0";
          if (hintR) hintR.style.opacity = "0";
        }
        container.addEventListener("touchstart", onStart, { passive: true });
        container.addEventListener("touchmove", onMove, { passive: false });
        container.addEventListener("touchend", onEnd);
      })();

      // QR Code functionality
      function generateQRCode(text, size = 200) {
        // Simple QR code generation using a free API
        const qrApiUrl = `https://api.qrserver.com/v1/create-qr-code/?size=${size}x${size}&data=${encodeURIComponent(
          text
        )}&bgcolor=ffffff&color=000000&margin=10`;
        return qrApiUrl;
      }

      function showQRModal() {
        const modal = document.getElementById("qrModal");
        const container = document.getElementById("qrCodeContainer");
        const url = "https://kwikmusicpersonal.netlify.app/";

        // Generate QR code
        const qrImageUrl = generateQRCode(url, 180);
        container.innerHTML = `<img src="${qrImageUrl}" alt="QR Code for KwikMusic" style="max-width: 100%; height: auto; border-radius: 8px;">`;

        modal.classList.add("show");

        // Add click outside to close
        modal.addEventListener("click", function (e) {
          if (e.target === modal) {
            closeQRModal();
          }
        });
      }

      function closeQRModal() {
        const modal = document.getElementById("qrModal");
        modal.classList.remove("show");
      }

      // Add double-click event to KwikMusic title
      document.addEventListener("DOMContentLoaded", function () {
        const appTitle = document.querySelector(".app-title");
        if (appTitle) {
          appTitle.style.cursor = "pointer";
          appTitle.style.userSelect = "none";

          let clickTimeout;
          let clickCount = 0;

          appTitle.addEventListener("click", function (e) {
            clickCount++;

            if (clickCount === 1) {
              clickTimeout = setTimeout(function () {
                clickCount = 0;
              }, 300);
            } else if (clickCount === 2) {
              clearTimeout(clickTimeout);
              clickCount = 0;
              showQRModal();
            }
          });
        }
      });

      // Close QR modal with Escape key
      document.addEventListener("keydown", function (e) {
        if (e.key === "Escape") {
          closeQRModal();
        }
      });

      // Initialize recordings system when app loads
      document.addEventListener("DOMContentLoaded", async function () {
        try {
          await initRecordingsDB();
          await loadRecordings(); // Load recordings to show badge if any exist

          // Set appropriate tooltip for record button based on device
          const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
          if (recordBtn) {
            recordBtn.title = isIOS
              ? "Record ambient audio (microphone)"
              : "Record high-quality audio (screen capture)";
          }

          // Check if app is offline on initial load and redirect to recordings
          handleOfflineMode();

          console.log("Recordings database initialized");
        } catch (error) {
          console.error("Failed to initialize recordings database:", error);
        }
      });

      // ===== AI Playlist Generator =====
      (function initAIPlaylistGenerator() {
        const aiPlaylistBtn = document.getElementById("aiPlaylistBtn");
        const aiPlaylistModal = document.getElementById("aiPlaylistModal");
        const aiCloseBtn = document.getElementById("aiCloseBtn");
        const aiGenerateBtn = document.getElementById("aiGenerateBtn");
        const playlistPromptInput = document.getElementById("playlistPrompt");
        const playlistNameInput = document.getElementById("playlistName");
        const aiStatus = document.getElementById("aiStatus");
        const aiStatusMessage = document.getElementById("aiStatusMessage");
        const aiProgress = document.getElementById("aiProgress");
        const aiProgressText = document.getElementById("aiProgressText");
        const aiProgressFill = document.getElementById("aiProgressFill");
        const exampleChips = document.querySelectorAll(".ai-example-chip");

        // Open modal
        aiPlaylistBtn.addEventListener("click", () => {
          aiPlaylistModal.classList.add("show");
          aiPlaylistBtn.classList.add("active");
        });

        // Close modal
        function closeAIModal() {
          aiPlaylistModal.classList.remove("show");
          aiPlaylistBtn.classList.remove("active");
          resetAIStatus();
        }

        aiCloseBtn.addEventListener("click", closeAIModal);
        aiPlaylistModal.addEventListener("click", (e) => {
          if (e.target === aiPlaylistModal) closeAIModal();
        });

        // Example chip click
        exampleChips.forEach((chip) => {
          chip.addEventListener("click", () => {
            playlistPromptInput.value = chip.dataset.prompt;
          });
        });

        // Reset status
        function resetAIStatus() {
          aiStatus.classList.remove("show", "loading", "success", "error");
          aiProgress.style.display = "none";
          aiStatusMessage.textContent = "";
        }

        // Show status
        function showStatus(type, message) {
          aiStatus.classList.remove("loading", "success", "error");
          aiStatus.classList.add("show", type);
          aiStatusMessage.textContent = message;
        }

        // Update progress
        function updateProgress(text, percent) {
          aiProgress.style.display = "block";
          aiProgressText.textContent = text;
          aiProgressFill.style.width = percent + "%";
        }

        // Vinyl loader functions
        const vinylLoader = document.getElementById("vinylLoader");
        const orbitContainer = document.getElementById("orbitContainer");
        const vinylStatusText = document.getElementById("vinylStatusText");
        const aiModalInner = document.querySelector(".ai-modal-inner");

        function showVinylLoader() {
          console.log(" Showing vinyl loader...");
          // Hide form elements and show vinyl
          aiModalInner.classList.add("vinyl-mode");
          vinylLoader.classList.add("active");
          console.log(" Classes added:", {
            vinylMode: aiModalInner.classList.contains("vinyl-mode"),
            active: vinylLoader.classList.contains("active"),
          });
          orbitContainer.innerHTML = `
            <div class="center-vinyl">
              <div class="vinyl-disc spinning-slow">
                <div class="vinyl-center"></div>
                <div class="vinyl-grooves"></div>
              </div>
            </div>
          `;
          vinylStatusText.textContent = "Curating your playlist...";
          console.log(" Vinyl loader should now be visible");
        }

        function hideVinylLoader() {
          vinylLoader.classList.remove("active");
          aiModalInner.classList.remove("vinyl-mode");
        }

        async function playCompletionAnimation() {
          // Update status text
          vinylStatusText.textContent = " Collecting records...";

          // Pause orbit rotation
          orbitContainer.classList.add("pause-orbit");

          // Get all orbiting records
          const orbitingRecords = document.querySelectorAll(".orbiting-record");

          // Fly each record to center with staggered delay
          orbitingRecords.forEach((record, index) => {
            setTimeout(() => {
              record.classList.add("fly-to-center");
            }, index * 150);
          });

          // Wait for all records to fly in
          await sleep(orbitingRecords.length * 150 + 800);

          // Zoom in center vinyl
          const centerVinyl = document.querySelector(".center-vinyl");
          centerVinyl.classList.add("zoom-complete");

          // Hide status text
          vinylStatusText.style.opacity = "0";

          // Wait for zoom animation
          await sleep(2000);
        }

        function addRecordToOrbit(track, index, total) {
          console.log(` Adding record ${index + 1}/${total}:`, track.title);

          const record = document.createElement("div");
          record.className = "orbiting-record";
          record.style.animationDelay = `${index * 0.3}s`;

          // Calculate position in a circle around center
          const angle = (360 / total) * index;
          const radius = 150; // Distance from center
          const radians = (angle * Math.PI) / 180;
          const x = Math.cos(radians) * radius;
          const y = Math.sin(radians) * radius;

          // Set position using CSS variables for animation compatibility
          record.style.setProperty("--orbit-x", `${x}px`);
          record.style.setProperty("--orbit-y", `${y}px`);

          const inner = document.createElement("div");
          inner.className = "orbiting-record-inner";

          const img = document.createElement("img");
          img.src =
            track.thumbnail ||
            `https://img.youtube.com/vi/${track.id}/mqdefault.jpg`;
          img.alt = track.title;
          img.onerror = () => {
            img.src = `https://img.youtube.com/vi/${track.id}/default.jpg`;
          };

          inner.appendChild(img);
          record.appendChild(inner);
          orbitContainer.appendChild(record);

          console.log(
            ` Record ${index + 1} added at position (${x.toFixed(
              0
            )}, ${y.toFixed(0)})`
          );
          vinylStatusText.textContent = `${
            index + 1
          } of ${total} songs added `;
        }

        // Generate playlist
        aiGenerateBtn.addEventListener("click", async () => {
          const prompt = playlistPromptInput.value.trim();

          if (!prompt) {
            showStatus(
              "error",
              "Please describe the playlist you want to create"
            );
            return;
          }

          try {
            aiGenerateBtn.disabled = true;
            resetAIStatus();
            showStatus("loading", "Asking AI for song recommendations...");
            updateProgress("Analyzing your request...", 10);

            // Call Gemini API
            const songs = await getAIRecommendations(GEMINI_API_KEY, prompt);
            updateProgress(
              `Found ${songs.length} songs! Searching YouTube...`,
              30
            );

            // Show vinyl loader
            showVinylLoader();

            // Search YouTube for each song
            const tracks = [];
            for (let i = 0; i < songs.length; i++) {
              const song = songs[i];

              try {
                const track = await searchYouTubeForSong(song);
                if (track) {
                  tracks.push(track);
                  // Add record to orbit with animation
                  addRecordToOrbit(track, tracks.length - 1, songs.length);
                  console.log(` Added: ${song}`);
                  await sleep(1000); // Slower for animation
                }
              } catch (err) {
                console.warn(`Failed to find: ${song}`, err);
              }
            }

            if (tracks.length === 0) {
              hideVinylLoader();
              showStatus("error", "Could not find any songs on YouTube");
              aiGenerateBtn.disabled = false;
              return;
            }

            vinylStatusText.textContent = ` Finalizing playlist...`;

            // Create playlist
            const playlistName =
              playlistNameInput.value.trim() || generatePlaylistName(prompt);
            const playlistId = createPlaylist(playlistName);

            // Add tracks to playlist
            tracks.forEach((track) => {
              addTrackToPlaylist(playlistId, track);
            });

            // Play completion animation
            await playCompletionAnimation();

            // Close modal with fade out
            hideVinylLoader();

            // Clear inputs
            playlistPromptInput.value = "";
            playlistNameInput.value = "";

            // Close and switch to playlists tab
            closeAIModal();
            setActiveTab("playlists");
            renderPlaylists();
          } catch (error) {
            console.error("AI Playlist Error:", error);
            hideVinylLoader();
            showStatus(
              "error",
              error.message || "Failed to generate playlist. Please try again."
            );
          } finally {
            aiGenerateBtn.disabled = false;
          }
        });

        // Call Gemini API to get song recommendations
        async function getAIRecommendations(apiKey, userPrompt) {
          const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;

          const systemPrompt = `You are a music expert. Based on the user's request, provide a list of song recommendations.

Rules:
1. Return ONLY a JSON array of strings
2. Each string should be in format: "Artist - Song Title"
3. Provide EXACTLY 5 songs (no more, no less)
4. Be specific with artist names and song titles
5. Focus on popular, well-known versions of songs

Example output format:
["Arijit Singh - Tum Hi Ho", "Arijit Singh - Channa Mereya", "Arijit Singh - Kesariya", "Atif Aslam - Tajdar-e-Haram", "Rahat Fateh Ali Khan - Afreen Afreen"]

User request: ${userPrompt}`;

          const response = await fetch(GEMINI_API_URL, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text: systemPrompt,
                    },
                  ],
                },
              ],
              generationConfig: {
                temperature: 0.7,
                maxOutputTokens: 2048,
                responseMimeType: "application/json",
              },
            }),
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(
              errorData.error?.message ||
                `API Error: ${response.status} ${response.statusText}`
            );
          }

          const data = await response.json();
          console.log("Gemini API Response:", data);

          let text =
            data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";

          if (!text) {
            console.error("Full API response:", JSON.stringify(data, null, 2));
            throw new Error("No response from AI. Check console for details.");
          }

          console.log("AI Response Text:", text);

          // Since we requested JSON mime type, the response should be pure JSON
          // But still handle markdown code blocks just in case
          let songs;
          try {
            // Try parsing directly as JSON first
            songs = JSON.parse(text);
          } catch (e) {
            // If that fails, try extracting from markdown code blocks
            let jsonMatch = text.match(/```json\s*(\[[\s\S]*?\])\s*```/);
            if (!jsonMatch) {
              jsonMatch = text.match(/\[[\s\S]*\]/);
            } else {
              jsonMatch[0] = jsonMatch[1]; // Use the captured group
            }

            if (!jsonMatch) {
              console.error("Could not find JSON array in response:", text);
              throw new Error(
                "AI did not return a valid song list. Response: " +
                  text.substring(0, 100)
              );
            }

            songs = JSON.parse(jsonMatch[0]);
          }

          if (!Array.isArray(songs) || songs.length === 0) {
            throw new Error("No songs found in AI response");
          }

          console.log("Parsed songs:", songs);
          return songs;
        }

        // Search YouTube for a song (simplified - no filtering)
        async function searchYouTubeForSong(
          songQuery,
          retryWithNextKey = true
        ) {
          const searchQuery = encodeURIComponent(songQuery);
          const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${searchQuery}&type=video&videoCategoryId=10&maxResults=1&key=${getYouTubeApiKey()}`;

          const response = await fetch(url);
          if (!response.ok) {
            if (response.status === 403) {
              console.warn(
                `YouTube API key ${currentApiKeyIndex + 1} quota exceeded`
              );
              if (
                retryWithNextKey &&
                currentApiKeyIndex < YOUTUBE_API_KEYS.length - 1
              ) {
                switchToNextApiKey();
                console.log(
                  `Retrying with API key ${currentApiKeyIndex + 1}...`
                );
                return searchYouTubeForSong(songQuery, false);
              } else {
                console.error("All YouTube API keys exhausted");
                throw new Error(
                  "YouTube API quota exceeded on all keys. Please try again tomorrow."
                );
              }
            }
            return null;
          }

          const data = await response.json();
          if (!data.items || data.items.length === 0) {
            console.warn(`No results found for: ${songQuery}`);
            return null;
          }

          const video = data.items[0];
          return {
            id: video.id.videoId,
            title: video.snippet.title,
            thumbnail:
              video.snippet.thumbnails.medium?.url ||
              video.snippet.thumbnails.default?.url,
            channelTitle: video.snippet.channelTitle,
          };
        }

        // Generate playlist name from prompt
        function generatePlaylistName(prompt) {
          // Simple name generation
          const words = prompt.split(" ").slice(0, 5);
          const name = words
            .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
            .join(" ");
          return name.length > 40 ? name.substring(0, 40) + "..." : name;
        }

        // Sleep utility
        function sleep(ms) {
          return new Promise((resolve) => setTimeout(resolve, ms));
        }
      })();
    </script>

    <!-- QR Code Modal -->
    <div id="qrModal" class="qr-modal">
      <div class="qr-modal-content">
        <h3> Share KwikMusic</h3>
        <div class="qr-code-container" id="qrCodeContainer">
          <!-- QR code will be generated here -->
        </div>
        <p>Scan this QR code to open KwikMusic on any device</p>
        <button class="qr-close-btn" onclick="closeQRModal()">Close</button>
      </div>
    </div>
  </body>
</html>
